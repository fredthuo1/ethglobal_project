import { ethers } from 'ethers';
import { ERC20__factory } from '@hyperlane-xyz/hyperlane-token';
export async function assertNativeBalances(multiProvider, signer, chains, minBalanceWei) {
    const address = await signer.getAddress();
    const minBalance = ethers.utils.formatEther(minBalanceWei.toString());
    await Promise.all(chains.map(async (chain) => {
        const balanceWei = await multiProvider
            .getProvider(chain)
            .getBalance(address);
        const balance = ethers.utils.formatEther(balanceWei);
        if (balanceWei.lte(minBalanceWei))
            throw new Error(`${address} has insufficient balance on ${chain}. At least ${minBalance} required but found ${balance.toString()} ETH`);
    }));
}
export async function assertTokenBalance(multiProvider, signer, chain, token, minBalanceWei) {
    const address = await signer.getAddress();
    const provider = multiProvider.getProvider(chain);
    const tokenContract = ERC20__factory.connect(token, provider);
    const balanceWei = await tokenContract.balanceOf(address);
    if (balanceWei.lte(minBalanceWei))
        throw new Error(`${address} has insufficient balance on ${chain} for token ${token}. At least ${minBalanceWei} wei required but found ${balanceWei.toString()} wei`);
}
//# sourceMappingURL=balances.js.map
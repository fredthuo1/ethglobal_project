import fs from 'fs';
import path from 'path';
import { parse as yamlParse, stringify as yamlStringify } from 'yaml';
import { objMerge } from '@hyperlane-xyz/sdk';
import { logBlue } from '../logger.js';
import { getTimestampForFilename } from './time.js';
export function readFileAtPath(filepath) {
    if (!fs.existsSync(filepath)) {
        throw Error(`File doesn't exist at ${filepath}`);
    }
    return fs.readFileSync(filepath, 'utf8');
}
export function writeFileAtPath(filepath, value) {
    const dirname = path.dirname(filepath);
    if (!fs.existsSync(dirname)) {
        fs.mkdirSync(dirname, { recursive: true });
    }
    fs.writeFileSync(filepath, value);
}
export function readJson(filepath) {
    return JSON.parse(readFileAtPath(filepath));
}
export function tryReadJson(filepath) {
    try {
        return readJson(filepath);
    }
    catch (error) {
        return null;
    }
}
export function writeJson(filepath, obj) {
    writeFileAtPath(filepath, JSON.stringify(obj, null, 2) + '\n');
}
export function mergeJson(filepath, obj) {
    if (fs.existsSync(filepath)) {
        const previous = readJson(filepath);
        writeJson(filepath, objMerge(previous, obj));
    }
    else {
        writeJson(filepath, obj);
    }
}
export function readYaml(filepath) {
    return yamlParse(readFileAtPath(filepath));
}
export function tryReadYamlAtPath(filepath) {
    try {
        return readYaml(filepath);
    }
    catch (error) {
        return null;
    }
}
export function writeYaml(filepath, obj) {
    writeFileAtPath(filepath, yamlStringify(obj, null, 2) + '\n');
}
export function mergeYaml(filepath, obj) {
    if (fs.existsSync(filepath)) {
        const previous = readYaml(filepath);
        writeYaml(filepath, objMerge(previous, obj));
    }
    else {
        writeYaml(filepath, obj);
    }
}
export function readYamlOrJson(filepath, format) {
    return resolveYamlOrJson(filepath, readJson, readYaml, format);
}
export function writeYamlOrJson(filepath, obj, format) {
    return resolveYamlOrJson(filepath, (f) => writeJson(f, obj), (f) => writeYaml(f, obj), format);
}
export function mergeYamlOrJson(filepath, obj, format) {
    return resolveYamlOrJson(filepath, (f) => mergeJson(f, obj), (f) => mergeYaml(f, obj), format);
}
function resolveYamlOrJson(filepath, jsonFn, yamlFn, format) {
    if (format === 'json' || filepath.endsWith('.json')) {
        return jsonFn(filepath);
    }
    else if (format === 'yaml' ||
        filepath.endsWith('.yaml') ||
        filepath.endsWith('.yml')) {
        return yamlFn(filepath);
    }
    else {
        throw new Error(`Invalid file format for ${filepath}`);
    }
}
export function prepNewArtifactsFiles(outPath, files) {
    const timestamp = getTimestampForFilename();
    const newPaths = [];
    for (const file of files) {
        const filePath = path.join(outPath, `${file.filename}-${timestamp}.json`);
        // Write empty object to ensure permissions are okay
        writeJson(filePath, {});
        newPaths.push(filePath);
        logBlue(`${file.description} will be written to ${filePath}`);
    }
    return newPaths;
}
//# sourceMappingURL=files.js.map
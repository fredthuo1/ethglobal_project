"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HypERC721App = exports.HypERC20App = void 0;
const sdk_1 = require("@hyperlane-xyz/sdk");
const utils_1 = require("@hyperlane-xyz/utils");
class HyperlaneTokenApp extends sdk_1.RouterApp {
    router(contracts) {
        return contracts.router;
    }
    async transfer(origin, destination, recipient, amountOrId) {
        const originRouter = this.getContracts(origin).router;
        const destinationDomain = this.multiProvider.getDomainId(destination);
        const gasPayment = await originRouter.quoteGasPayment(destinationDomain);
        return this.multiProvider.handleTx(origin, originRouter.transferRemote(destinationDomain, utils_1.utils.addressToBytes32(recipient), amountOrId, {
            value: gasPayment,
        }));
    }
}
class HypERC20App extends HyperlaneTokenApp {
    async transfer(origin, destination, recipient, amount) {
        const originRouter = this.getContracts(origin).router;
        const signerAddress = await this.multiProvider.getSignerAddress(origin);
        const balance = await originRouter.balanceOf(signerAddress);
        if (balance.lt(amount))
            console.warn(`Signer ${signerAddress} has insufficient balance ${balance}, needs ${amount} on ${origin}`);
        return super.transfer(origin, destination, recipient, amount);
    }
}
exports.HypERC20App = HypERC20App;
class HypERC721App extends HyperlaneTokenApp {
    async transfer(origin, destination, recipient, tokenId) {
        const originRouter = this.getContracts(origin).router;
        const signerAddress = await this.multiProvider.getSignerAddress(origin);
        const owner = await originRouter.ownerOf(tokenId);
        if (signerAddress != owner)
            console.warn(`Signer ${signerAddress} not owner of token ${tokenId} on ${origin}`);
        return super.transfer(origin, destination, recipient, tokenId);
    }
}
exports.HypERC721App = HypERC721App;
//# sourceMappingURL=app.js.map
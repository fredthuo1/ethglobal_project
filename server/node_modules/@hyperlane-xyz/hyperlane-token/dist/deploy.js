"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HypERC721Deployer = exports.HypERC20Deployer = void 0;
const sdk_1 = require("@hyperlane-xyz/sdk");
const config_1 = require("./config");
const types_1 = require("./types");
class HypERC20Deployer extends sdk_1.GasRouterDeployer {
    constructor(multiProvider) {
        super(multiProvider, {}); // factories not used in deploy
    }
    static async fetchMetadata(provider, config) {
        const erc20 = types_1.ERC20__factory.connect(config.token, provider);
        const [name, symbol, totalSupply, decimals] = await Promise.all([
            erc20.name(),
            erc20.symbol(),
            erc20.totalSupply(),
            erc20.decimals(),
        ]);
        return { name, symbol, totalSupply, decimals };
    }
    static gasOverheadDefault(config) {
        switch (config.type) {
            case 'synthetic':
                return 64000;
            case 'native':
                return 44000;
            case 'collateral':
            default:
                return 68000;
        }
    }
    // Gets the metadata for a collateral token, favoring the config
    // and getting any on-chain metadata that is missing.
    async getCollateralMetadata(chain, config) {
        const metadata = {
            name: config.name,
            symbol: config.symbol,
            decimals: config.decimals,
            totalSupply: 0,
        };
        if (metadata.name &&
            metadata.symbol &&
            metadata.decimals !== undefined &&
            metadata.decimals !== null) {
            return metadata;
        }
        const fetchedMetadata = await HypERC20Deployer.fetchMetadata(this.multiProvider.getProvider(chain), config);
        // Filter out undefined values
        const definedConfigMetadata = Object.fromEntries(Object.entries(metadata).filter(([_, v]) => v !== undefined));
        return {
            ...fetchedMetadata,
            ...definedConfigMetadata,
        };
    }
    async deployCollateral(chain, config) {
        const router = await this.deployContractFromFactory(chain, new types_1.HypERC20Collateral__factory(), 'HypERC20Collateral', [config.token]);
        await this.multiProvider.handleTx(chain, router.initialize(config.mailbox, config.interchainGasPaymaster));
        return router;
    }
    async deployNative(chain, config) {
        const router = await this.deployContractFromFactory(chain, new types_1.HypNative__factory(), 'HypNative', []);
        await this.multiProvider.handleTx(chain, router.initialize(config.mailbox, config.interchainGasPaymaster));
        return router;
    }
    async deploySynthetic(chain, config) {
        const router = await this.deployContractFromFactory(chain, new types_1.HypERC20__factory(), 'HypERC20', [config.decimals]);
        await this.multiProvider.handleTx(chain, router.initialize(config.mailbox, config.interchainGasPaymaster, config.totalSupply, config.name, config.symbol));
        return router;
    }
    router(contracts) {
        return contracts.router;
    }
    async deployContracts(chain, config) {
        let router;
        if ((0, config_1.isCollateralConfig)(config)) {
            router = await this.deployCollateral(chain, config);
        }
        else if ((0, config_1.isNativeConfig)(config)) {
            router = await this.deployNative(chain, config);
        }
        else if ((0, config_1.isSyntheticConfig)(config)) {
            router = await this.deploySynthetic(chain, config);
        }
        else {
            throw new Error('Invalid ERC20 token router config');
        }
        return { router };
    }
    async buildTokenMetadata(configMap) {
        let tokenMetadata;
        for (const [chain, config] of Object.entries(configMap)) {
            if ((0, config_1.isCollateralConfig)(config)) {
                const collateralMetadata = await this.getCollateralMetadata(chain, config);
                tokenMetadata = {
                    ...collateralMetadata,
                    totalSupply: 0,
                };
            }
            else if ((0, config_1.isNativeConfig)(config)) {
                const chainMetadata = this.multiProvider.getChainMetadata(chain);
                if (chainMetadata.nativeToken) {
                    tokenMetadata = {
                        ...chainMetadata.nativeToken,
                        totalSupply: 0,
                    };
                }
                else {
                    throw new Error(`Warp route config specifies native token but chain metadata for ${chain} does not provide native token details`);
                }
            }
            else if ((0, config_1.isErc20Metadata)(config)) {
                tokenMetadata = config;
            }
        }
        if (!(0, config_1.isErc20Metadata)(tokenMetadata)) {
            throw new Error('Invalid ERC20 token metadata');
        }
        return (0, sdk_1.objMap)(configMap, () => tokenMetadata);
    }
    buildGasOverhead(configMap) {
        return (0, sdk_1.objMap)(configMap, (_, config) => ({
            gas: HypERC20Deployer.gasOverheadDefault(config),
        }));
    }
    async deploy(configMap) {
        const tokenMetadata = await this.buildTokenMetadata(configMap);
        const gasOverhead = this.buildGasOverhead(configMap);
        const mergedConfig = (0, sdk_1.objMap)(configMap, (chain, config) => {
            return {
                ...tokenMetadata[chain],
                ...gasOverhead[chain],
                ...config,
            };
        });
        return super.deploy(mergedConfig);
    }
}
exports.HypERC20Deployer = HypERC20Deployer;
class HypERC721Deployer extends sdk_1.GasRouterDeployer {
    constructor(multiProvider) {
        super(multiProvider, {}); // factories not used in deploy
    }
    static async fetchMetadata(provider, config) {
        const erc721 = types_1.ERC721EnumerableUpgradeable__factory.connect(config.token, provider);
        const [name, symbol, totalSupply] = await Promise.all([
            erc721.name(),
            erc721.symbol(),
            erc721.totalSupply(),
        ]);
        return { name, symbol, totalSupply };
    }
    static gasOverheadDefault(config) {
        switch (config.type) {
            case 'synthetic':
                return 160000;
            case 'syntheticUri':
                return 163000;
            case 'collateral':
            case 'collateralUri':
            default:
                return 80000;
        }
    }
    async deployCollateral(chain, config) {
        let router;
        if ((0, config_1.isUriConfig)(config)) {
            router = await this.deployContractFromFactory(chain, new types_1.HypERC721URICollateral__factory(), 'HypERC721URICollateral', [config.token]);
        }
        else {
            router = await this.deployContractFromFactory(chain, new types_1.HypERC721Collateral__factory(), 'HypERC721Collateral', [config.token]);
        }
        await this.multiProvider.handleTx(chain, router.initialize(config.mailbox, config.interchainGasPaymaster));
        return router;
    }
    async deploySynthetic(chain, config) {
        let router;
        if ((0, config_1.isUriConfig)(config)) {
            router = await this.deployContractFromFactory(chain, new types_1.HypERC721URIStorage__factory(), 'HypERC721URIStorage', []);
        }
        else {
            router = await this.deployContractFromFactory(chain, new types_1.HypERC721__factory(), 'HypERC721', []);
        }
        await this.multiProvider.handleTx(chain, router.initialize(config.mailbox, config.interchainGasPaymaster, config.totalSupply, config.name, config.symbol));
        return router;
    }
    router(contracts) {
        return contracts.router;
    }
    async deployContracts(chain, config) {
        let router;
        if ((0, config_1.isCollateralConfig)(config)) {
            router = await this.deployCollateral(chain, config);
        }
        else if ((0, config_1.isSyntheticConfig)(config)) {
            router = await this.deploySynthetic(chain, config);
        }
        else {
            throw new Error('Invalid ERC721 token router config');
        }
        return { router };
    }
    async buildTokenMetadata(configMap) {
        let tokenMetadata;
        for (const [chain, config] of Object.entries(configMap)) {
            if ((0, config_1.isCollateralConfig)(config)) {
                const collateralMetadata = await HypERC721Deployer.fetchMetadata(this.multiProvider.getProvider(chain), config);
                tokenMetadata = {
                    ...collateralMetadata,
                    totalSupply: 0,
                };
            }
            else if ((0, config_1.isTokenMetadata)(config)) {
                tokenMetadata = config;
            }
        }
        if (!(0, config_1.isTokenMetadata)(tokenMetadata)) {
            throw new Error('Invalid ERC721 token metadata');
        }
        return (0, sdk_1.objMap)(configMap, () => tokenMetadata);
    }
    buildGasOverhead(configMap) {
        return (0, sdk_1.objMap)(configMap, (_, config) => ({
            gas: HypERC721Deployer.gasOverheadDefault(config),
        }));
    }
    async deploy(configMap) {
        const tokenMetadata = await this.buildTokenMetadata(configMap);
        const gasOverhead = this.buildGasOverhead(configMap);
        const mergedConfig = (0, sdk_1.objMap)(configMap, (chain, config) => {
            return {
                ...tokenMetadata[chain],
                ...gasOverhead[chain],
                ...config,
            };
        });
        return super.deploy(mergedConfig);
    }
}
exports.HypERC721Deployer = HypERC721Deployer;
//# sourceMappingURL=deploy.js.map
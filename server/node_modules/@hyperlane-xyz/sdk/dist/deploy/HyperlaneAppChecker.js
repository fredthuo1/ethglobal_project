"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneAppChecker = void 0;
const utils_1 = require("ethers/lib/utils");
const utils_2 = require("@hyperlane-xyz/utils");
const contracts_1 = require("../contracts");
const objects_1 = require("../utils/objects");
const proxy_1 = require("./proxy");
const types_1 = require("./types");
class HyperlaneAppChecker {
    constructor(multiProvider, app, configMap) {
        this.multiProvider = multiProvider;
        this.app = app;
        this.violations = [];
        this.configMap = configMap;
    }
    async check() {
        Object.keys(this.configMap)
            .filter((_) => !this.app.chains().includes(_))
            .forEach((chain) => this.addViolation({
            type: types_1.ViolationType.NotDeployed,
            chain,
            expected: '',
            actual: '',
        }));
        return Promise.all(this.app.chains().map((chain) => this.checkChain(chain)));
    }
    addViolation(violation) {
        this.violations.push(violation);
    }
    async checkProxiedContracts(chain) {
        const expectedAdmin = this.app.getContracts(chain).proxyAdmin.address;
        if (!expectedAdmin) {
            throw new Error(`Checking proxied contracts for ${chain} with no admin provided`);
        }
        const provider = this.multiProvider.getProvider(chain);
        const contracts = this.app.getContracts(chain);
        await (0, objects_1.promiseObjAll)((0, objects_1.objMap)(contracts, async (name, contract) => {
            if (await (0, proxy_1.isProxy)(provider, contract.address)) {
                // Check the ProxiedContract's admin matches expectation
                const actualAdmin = await (0, proxy_1.proxyAdmin)(provider, contract.address);
                if (!utils_2.utils.eqAddress(actualAdmin, expectedAdmin)) {
                    this.addViolation({
                        type: types_1.ViolationType.ProxyAdmin,
                        chain,
                        name,
                        expected: expectedAdmin,
                        actual: actualAdmin,
                    });
                }
            }
        }));
    }
    async checkUpgrade(chain, upgradeConfig) {
        const timelockController = this.app.getContracts(chain)
            .timelockController;
        if (!timelockController) {
            throw new Error(`Checking upgrade config for ${chain} with no timelock provided`);
        }
        const minDelay = (await timelockController.getMinDelay()).toNumber();
        if (minDelay !== upgradeConfig.timelock.delay) {
            const violation = {
                type: types_1.ViolationType.TimelockController,
                chain,
                actual: minDelay,
                expected: upgradeConfig.timelock.delay,
                contract: timelockController,
            };
            this.addViolation(violation);
        }
        const roleIds = {
            executor: await timelockController.EXECUTOR_ROLE(),
            proposer: await timelockController.PROPOSER_ROLE(),
            canceller: await timelockController.CANCELLER_ROLE(),
            admin: await timelockController.TIMELOCK_ADMIN_ROLE(),
        };
        const accountHasRole = await (0, objects_1.promiseObjAll)((0, objects_1.objMap)(upgradeConfig.timelock.roles, async (role, account) => ({
            hasRole: await timelockController.hasRole(roleIds[role], account),
            account,
        })));
        for (const [role, { hasRole, account }] of Object.entries(accountHasRole)) {
            if (!hasRole) {
                const violation = {
                    type: types_1.ViolationType.AccessControl,
                    chain,
                    account,
                    actual: false,
                    expected: true,
                    contract: timelockController,
                    role,
                };
                this.addViolation(violation);
            }
        }
    }
    removeBytecodeMetadata(bytecode) {
        // https://docs.soliditylang.org/en/v0.8.17/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode
        // Remove solc metadata from bytecode
        return bytecode.substring(0, bytecode.length - 90);
    }
    // This method checks whether the bytecode of a contract matches the expected bytecode. It forces the deployer to explicitly acknowledge a change in bytecode. The violations can be remediated by updating the expected bytecode hash.
    async checkBytecode(chain, name, address, expectedBytecodeHashes, modifyBytecodePriorToHash = (_) => _) {
        const provider = this.multiProvider.getProvider(chain);
        const bytecode = await provider.getCode(address);
        const bytecodeHash = (0, utils_1.keccak256)(modifyBytecodePriorToHash(this.removeBytecodeMetadata(bytecode)));
        if (!expectedBytecodeHashes.includes(bytecodeHash)) {
            this.addViolation({
                type: types_1.ViolationType.BytecodeMismatch,
                chain,
                expected: expectedBytecodeHashes,
                actual: bytecodeHash,
                name,
            });
        }
    }
    async ownables(chain) {
        const contracts = this.app.getContracts(chain);
        return (0, contracts_1.filterOwnableContracts)(contracts);
    }
    async checkOwnership(chain, owner, ownableOverrides) {
        const ownableContracts = await this.ownables(chain);
        for (const [name, contract] of Object.entries(ownableContracts)) {
            const expectedOwner = ownableOverrides?.[name] ?? owner;
            const actual = await contract.owner();
            if (!utils_2.utils.eqAddress(actual, expectedOwner)) {
                const violation = {
                    chain,
                    name,
                    type: types_1.ViolationType.Owner,
                    actual,
                    expected: expectedOwner,
                    contract,
                };
                this.addViolation(violation);
            }
        }
    }
    expectViolations(violationCounts) {
        // Every type should have exactly the number of expected matches.
        (0, objects_1.objMap)(violationCounts, (type, count) => {
            const actual = this.violations.filter((v) => v.type === type).length;
            utils_2.utils.assert(actual == count, `Expected ${count} ${type} violations, got ${actual}`);
        });
        this.violations
            .filter((v) => !(v.type in violationCounts))
            .map((v) => {
            utils_2.utils.assert(false, `Unexpected violation: ${JSON.stringify(v)}`);
        });
    }
    expectEmpty() {
        const count = this.violations.length;
        utils_2.utils.assert(count === 0, `Found ${count} violations`);
    }
}
exports.HyperlaneAppChecker = HyperlaneAppChecker;
//# sourceMappingURL=HyperlaneAppChecker.js.map
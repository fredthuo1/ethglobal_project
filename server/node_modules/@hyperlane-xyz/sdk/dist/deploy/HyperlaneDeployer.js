"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneDeployer = void 0;
const debug_1 = require("debug");
const ethers_1 = require("ethers");
const core_1 = require("@hyperlane-xyz/core");
const utils_1 = require("@hyperlane-xyz/utils");
const HyperlaneIsmFactory_1 = require("../ism/HyperlaneIsmFactory");
const proxy_1 = require("./proxy");
const utils_2 = require("./verify/utils");
class HyperlaneDeployer {
    constructor(multiProvider, factories, options) {
        this.multiProvider = multiProvider;
        this.factories = factories;
        this.options = options;
        this.verificationInputs = {};
        this.cachedAddresses = {};
        this.deployedContracts = {};
        this.startingBlockNumbers = {};
        this.logger = options?.logger ?? (0, debug_1.debug)('hyperlane:deployer');
        this.chainTimeoutMs = options?.chainTimeoutMs ?? 5 * 60 * 1000; // 5 minute timeout per chain
    }
    cacheAddressesMap(addressesMap) {
        this.cachedAddresses = addressesMap;
    }
    async checkConfig(_) {
        return;
    }
    async deploy(configMap) {
        const configChains = Object.keys(configMap);
        const targetChains = this.multiProvider.intersect(configChains, true).intersection;
        this.logger(`Start deploy to ${targetChains}`);
        for (const chain of targetChains) {
            const signerUrl = await this.multiProvider.tryGetExplorerAddressUrl(chain);
            const signerAddress = await this.multiProvider.getSignerAddress(chain);
            const fromString = signerUrl || signerAddress;
            this.logger(`Deploying to ${chain} from ${fromString}`);
            this.startingBlockNumbers[chain] = await this.multiProvider
                .getProvider(chain)
                .getBlockNumber();
            await utils_1.utils.runWithTimeout(this.chainTimeoutMs, async () => {
                this.deployedContracts[chain] = await this.deployContracts(chain, configMap[chain]);
            });
        }
        return this.deployedContracts;
    }
    async runIf(chain, address, fn, label = 'address') {
        const signer = await this.multiProvider.getSignerAddress(chain);
        if (utils_1.utils.eqAddress(address, signer)) {
            return fn();
        }
        else {
            this.logger(`Signer (${signer}) does not match ${label} (${address})`);
        }
        return undefined;
    }
    async runIfOwner(chain, ownable, fn) {
        return this.runIf(chain, await ownable.callStatic.owner(), fn, 'owner');
    }
    async runIfAdmin(chain, proxy, signerAdminFn, proxyAdminOwnerFn) {
        const admin = await (0, proxy_1.proxyAdmin)(this.multiProvider.getProvider(chain), proxy.address);
        const code = await this.multiProvider.getProvider(chain).getCode(admin);
        // if admin is a ProxyAdmin, run the proxyAdminOwnerFn (if deployer is owner)
        if (code !== '0x') {
            this.logger(`Admin is a ProxyAdmin (${admin})`);
            const proxyAdmin = core_1.ProxyAdmin__factory.connect(admin, proxy.signer);
            return this.runIfOwner(chain, proxyAdmin, () => proxyAdminOwnerFn(proxyAdmin));
        }
        else {
            this.logger(`Admin is an EOA (${admin})`);
            // if admin is an EOA, run the signerAdminFn (if deployer is admin)
            return this.runIf(chain, admin, () => signerAdminFn(), 'admin');
        }
    }
    async initConnectionClient(local, connectionClient, config) {
        this.logger(`Initializing connection client (if not already) on ${local}...`);
        await this.runIfOwner(local, connectionClient, async () => {
            const txOverrides = this.multiProvider.getTransactionOverrides(local);
            // set mailbox if not already set (and configured)
            if (config.mailbox !== (await connectionClient.mailbox())) {
                this.logger(`Set mailbox on (${local})`);
                await this.multiProvider.handleTx(local, connectionClient.setMailbox(config.mailbox, txOverrides));
            }
            // set interchain gas paymaster if not already set (and configured)
            if (config.interchainGasPaymaster !==
                (await connectionClient.interchainGasPaymaster())) {
                this.logger(`Set interchain gas paymaster on ${local}`);
                await this.multiProvider.handleTx(local, connectionClient.setInterchainGasPaymaster(config.interchainGasPaymaster, txOverrides));
            }
            let currentIsm = await connectionClient.interchainSecurityModule();
            // in case the above returns zero address, fetch the defaultISM from the mailbox
            if (currentIsm === ethers_1.ethers.constants.AddressZero) {
                const mailbox = core_1.Mailbox__factory.connect(config.mailbox, connectionClient.signer);
                currentIsm = await mailbox.defaultIsm();
            }
            if (config.interchainSecurityModule) {
                // set interchain security module if not already set (and configured)
                let configuredIsm;
                if (typeof config.interchainSecurityModule === 'string') {
                    configuredIsm = config.interchainSecurityModule;
                }
                else if (this.options?.ismFactory) {
                    const matches = await (0, HyperlaneIsmFactory_1.moduleMatchesConfig)(local, currentIsm, config.interchainSecurityModule, this.multiProvider, this.options.ismFactory.chainMap[local]);
                    if (matches) {
                        // when the ISM recursively matches the IsmConfig, we don't need to deploy a new ISM
                        this.logger(`ISM matches config for chain ${local}, skipping deploy`);
                        return;
                    }
                    const ism = await this.options.ismFactory.deploy(local, config.interchainSecurityModule);
                    configuredIsm = ism.address;
                }
                else {
                    throw new Error('No ISM factory provided');
                }
                this.logger(`Set interchain security module on ${local} at ${configuredIsm}`);
                await this.multiProvider.handleTx(local, connectionClient.setInterchainSecurityModule(configuredIsm, txOverrides));
            }
        });
        this.logger(`Connection client on ${local} initialized...`);
    }
    async deployContractFromFactory(chain, factory, contractName, constructorArgs, initializeArgs) {
        const cachedContract = this.readCache(chain, factory, contractName);
        if (cachedContract) {
            return cachedContract;
        }
        const signer = this.multiProvider.getSigner(chain);
        const overrides = this.multiProvider.getTransactionOverrides(chain);
        this.logger(`Deploy ${contractName} on ${chain}`);
        const contract = await factory
            .connect(signer)
            .deploy(...constructorArgs, overrides);
        await this.multiProvider.handleTx(chain, contract.deployTransaction);
        if (initializeArgs) {
            this.logger(`Initialize ${contractName} on ${chain}`);
            const initTx = await contract.initialize(...initializeArgs, overrides);
            await this.multiProvider.handleTx(chain, initTx);
        }
        const verificationInput = (0, utils_2.getContractVerificationInput)(contractName, contract, factory.bytecode);
        this.verificationInputs[chain] = this.verificationInputs[chain] || [];
        this.verificationInputs[chain].push(verificationInput);
        return contract;
    }
    async deployContract(chain, contractName, constructorArgs, initializeArgs) {
        const contract = (await this.deployContractFromFactory(chain, this.factories[contractName], contractName.toString(), constructorArgs, initializeArgs));
        this.writeCache(chain, contractName, contract.address);
        return contract;
    }
    async changeAdmin(chain, proxy, admin) {
        const actualAdmin = await (0, proxy_1.proxyAdmin)(this.multiProvider.getProvider(chain), proxy.address);
        if (utils_1.utils.eqAddress(admin, actualAdmin)) {
            this.logger(`Admin set correctly, skipping admin change`);
            return;
        }
        const txOverrides = this.multiProvider.getTransactionOverrides(chain);
        this.logger(`Changing proxy admin`);
        await this.runIfAdmin(chain, proxy, () => this.multiProvider.handleTx(chain, proxy.changeAdmin(admin, txOverrides)), (proxyAdmin) => this.multiProvider.handleTx(chain, proxyAdmin.changeProxyAdmin(proxy.address, admin, txOverrides)));
    }
    async upgradeAndInitialize(chain, proxy, implementation, initializeArgs) {
        const current = await proxy.callStatic.implementation();
        if (utils_1.utils.eqAddress(implementation.address, current)) {
            this.logger(`Implementation set correctly, skipping upgrade`);
            return;
        }
        this.logger(`Upgrading and initializing implementation`);
        const initData = implementation.interface.encodeFunctionData('initialize', initializeArgs);
        const overrides = this.multiProvider.getTransactionOverrides(chain);
        await this.runIfAdmin(chain, proxy, () => this.multiProvider.handleTx(chain, proxy.upgradeToAndCall(implementation.address, initData, overrides)), (proxyAdmin) => this.multiProvider.handleTx(chain, proxyAdmin.upgradeAndCall(proxy.address, implementation.address, initData, overrides)));
    }
    async deployProxy(chain, implementation, proxyAdmin, initializeArgs) {
        const initData = initializeArgs
            ? implementation.interface.encodeFunctionData('initialize', initializeArgs)
            : '0x';
        this.logger(`Deploying transparent upgradable proxy`);
        const constructorArgs = [
            implementation.address,
            proxyAdmin,
            initData,
        ];
        const proxy = await this.deployContractFromFactory(chain, new core_1.TransparentUpgradeableProxy__factory(), 'TransparentUpgradeableProxy', constructorArgs);
        return implementation.attach(proxy.address);
    }
    async deployTimelock(chain, timelockConfig) {
        const timelock = await this.deployContractFromFactory(chain, new core_1.TimelockController__factory(), 'timelockController', 
        // delay, [proposers], [executors], admin
        [
            timelockConfig.delay,
            [timelockConfig.roles.proposer],
            [timelockConfig.roles.executor],
            ethers_1.ethers.constants.AddressZero,
        ]);
        return timelock;
    }
    writeCache(chain, contractName, address) {
        if (!this.cachedAddresses[chain]) {
            this.cachedAddresses[chain] = {};
        }
        this.cachedAddresses[chain][contractName] = address;
    }
    readCache(chain, factory, contractName) {
        const cachedAddress = this.cachedAddresses[chain]?.[contractName];
        const hit = !!cachedAddress && cachedAddress !== ethers_1.ethers.constants.AddressZero;
        const contractAddress = hit ? cachedAddress : ethers_1.ethers.constants.AddressZero;
        const contract = factory
            .attach(contractAddress)
            .connect(this.multiProvider.getSignerOrProvider(chain));
        if (hit) {
            this.logger(`Recovered ${contractName.toString()} on ${chain} ${cachedAddress}`);
            return contract;
        }
        return undefined;
    }
    /**
     * Deploys the Implementation and Proxy for a given contract
     *
     */
    async deployProxiedContract(chain, contractName, proxyAdmin, constructorArgs, initializeArgs) {
        const cachedContract = this.readCache(chain, this.factories[contractName], contractName.toString());
        if (cachedContract) {
            return cachedContract;
        }
        // Try to initialize the implementation even though it may not be necessary
        const implementation = await this.deployContract(chain, contractName, constructorArgs, initializeArgs);
        // Initialize the proxy the same way
        const contract = await this.deployProxy(chain, implementation, proxyAdmin, initializeArgs);
        this.writeCache(chain, contractName, contract.address);
        return contract;
    }
    mergeWithExistingVerificationInputs(existingInputsMap) {
        const allChains = new Set();
        Object.keys(existingInputsMap).forEach((_) => allChains.add(_));
        Object.keys(this.verificationInputs).forEach((_) => allChains.add(_));
        const ret = {};
        for (const chain of allChains) {
            const existingInputs = existingInputsMap[chain] || [];
            const newInputs = this.verificationInputs[chain] || [];
            ret[chain] = [...existingInputs, ...newInputs];
        }
        return ret;
    }
    async transferOwnershipOfContracts(chain, owner, ownables) {
        const receipts = [];
        for (const contractName of Object.keys(ownables)) {
            const ownable = ownables[contractName];
            const currentOwner = await ownable.owner();
            if (!utils_1.utils.eqAddress(currentOwner, owner)) {
                this.logger(`Transferring ownership of ${contractName} to ${owner} on ${chain}`);
                const receipt = await this.runIfOwner(chain, ownable, () => this.multiProvider.handleTx(chain, ownable.transferOwnership(owner, this.multiProvider.getTransactionOverrides(chain))));
                if (receipt)
                    receipts.push(receipt);
            }
        }
        return receipts.filter((x) => !!x);
    }
}
exports.HyperlaneDeployer = HyperlaneDeployer;
//# sourceMappingURL=HyperlaneDeployer.js.map
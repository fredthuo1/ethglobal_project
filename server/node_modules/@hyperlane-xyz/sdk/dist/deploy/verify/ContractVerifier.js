"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractVerifier = void 0;
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const debug_1 = require("debug");
const ethers_1 = require("ethers");
const utils_1 = require("@hyperlane-xyz/utils");
const utils_2 = require("@hyperlane-xyz/utils/dist/src/utils");
const MultiGeneric_1 = require("../../utils/MultiGeneric");
var ExplorerApiActions;
(function (ExplorerApiActions) {
    ExplorerApiActions["GETSOURCECODE"] = "getsourcecode";
    ExplorerApiActions["VERIFY_IMPLEMENTATION"] = "verifysourcecode";
    ExplorerApiActions["MARK_PROXY"] = "verifyproxycontract";
    ExplorerApiActions["CHECK_STATUS"] = "checkverifystatus";
    ExplorerApiActions["CHECK_PROXY_STATUS"] = "checkproxyverification";
})(ExplorerApiActions || (ExplorerApiActions = {}));
var ExplorerApiErrors;
(function (ExplorerApiErrors) {
    ExplorerApiErrors["ALREADY_VERIFIED"] = "Contract source code already verified";
    ExplorerApiErrors["ALREADY_VERIFIED_ALT"] = "Already Verified";
    ExplorerApiErrors["VERIFICATION_PENDING"] = "Pending in queue";
    ExplorerApiErrors["PROXY_FAILED"] = "A corresponding implementation contract was unfortunately not detected for the proxy address.";
})(ExplorerApiErrors || (ExplorerApiErrors = {}));
class ContractVerifier extends MultiGeneric_1.MultiGeneric {
    constructor(verificationInputs, multiProvider, apiKeys, flattenedSource, // flattened source code from eg `hardhat flatten`
    compilerOptions) {
        super(verificationInputs);
        this.multiProvider = multiProvider;
        this.apiKeys = apiKeys;
        this.flattenedSource = flattenedSource;
        this.compilerOptions = compilerOptions;
        this.logger = (0, debug_1.debug)('hyperlane:ContractVerifier');
    }
    verify(targets = this.chains()) {
        return Promise.allSettled(targets.map((chain) => this.verifyChain(chain, this.get(chain))));
    }
    async verifyChain(chain, inputs) {
        this.logger(`Verifying ${chain}...`);
        for (const input of inputs) {
            await this.verifyContract(chain, input);
        }
    }
    async submitForm(chain, action, options) {
        const apiUrl = new URL(this.multiProvider.getExplorerApiUrl(chain));
        const isGetRequest = action === ExplorerApiActions.CHECK_STATUS ||
            action === ExplorerApiActions.CHECK_PROXY_STATUS ||
            action === ExplorerApiActions.GETSOURCECODE;
        const params = new URLSearchParams({
            apikey: this.apiKeys[chain],
            module: 'contract',
            action,
            ...options,
        });
        let response;
        if (isGetRequest) {
            response = await (0, cross_fetch_1.default)(`${apiUrl}?${params}`);
        }
        else {
            response = await (0, cross_fetch_1.default)(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: params,
            });
        }
        let result;
        let responseText;
        try {
            responseText = await response.text();
            result = JSON.parse(responseText);
        }
        catch (e) {
            this.logger(`Failed to parse response from ${responseText}`, e);
        }
        if (result.message === 'NOTOK') {
            switch (result.result) {
                case ExplorerApiErrors.VERIFICATION_PENDING:
                    await utils_1.utils.sleep(5000); // wait 5 seconds
                    return this.submitForm(chain, action, options);
                case ExplorerApiErrors.ALREADY_VERIFIED:
                case ExplorerApiErrors.ALREADY_VERIFIED_ALT:
                    return;
                case ExplorerApiErrors.PROXY_FAILED:
                    this.logger(`Proxy verification failed, try manually?`);
                    return;
                default:
                    this.logger(`Verification failed for some unknown reason on ${chain}`, result);
                    throw new Error(`Verification failed: ${result.result}`);
            }
        }
        return result.result;
    }
    async isAlreadyVerified(chain, input) {
        try {
            const result = await this.submitForm(chain, ExplorerApiActions.GETSOURCECODE, {
                ...this.compilerOptions,
                address: input.address,
            });
            return result[0].SourceCode !== '';
        }
        catch (error) {
            this.logger(`Error checking if contract is already verified: ${error}`);
            return false;
        }
    }
    async verifyProxy(chain, input) {
        if (input.isProxy) {
            try {
                const proxyGuid = await this.submitForm(chain, ExplorerApiActions.MARK_PROXY, {
                    address: input.address,
                });
                const addressUrl = await this.multiProvider.tryGetExplorerAddressUrl(chain, input.address);
                // poll for verified proxy status
                if (proxyGuid) {
                    await this.submitForm(chain, ExplorerApiActions.CHECK_PROXY_STATUS, {
                        guid: proxyGuid,
                    });
                    this.logger(`Successfully verified proxy ${addressUrl}#readProxyContract`);
                }
            }
            catch (error) {
                console.error(`Verification of proxy at ${input.address} failed on ${chain}`);
                throw error;
            }
        }
    }
    async verifyImplementation(chain, input) {
        this.logger(`Verifying ${input.name} implementation at ${input.address} on ${chain}`);
        const data = {
            sourceCode: this.flattenedSource,
            contractname: input.name,
            contractaddress: input.address,
            // TYPO IS ENFORCED BY API
            constructorArguements: utils_1.utils.strip0x(input.constructorArguments ?? ''),
            ...this.compilerOptions,
        };
        const guid = await this.submitForm(chain, ExplorerApiActions.VERIFY_IMPLEMENTATION, data);
        const addressUrl = await this.multiProvider.tryGetExplorerAddressUrl(chain, input.address);
        // poll for verified status
        if (guid) {
            try {
                await this.submitForm(chain, ExplorerApiActions.CHECK_STATUS, { guid });
                this.logger(`Successfully verified ${addressUrl}#code`);
            }
            catch (error) {
                console.error(`Verifying implementation at ${input.address} failed on ${chain}`);
                throw error;
            }
        }
    }
    async verifyContract(chain, input) {
        if (input.address === ethers_1.ethers.constants.AddressZero) {
            return;
        }
        if (Array.isArray(input.constructorArguments)) {
            this.logger('Constructor arguments in legacy format, skipping');
            return;
        }
        if (await this.isAlreadyVerified(chain, input)) {
            this.logger(`Contract ${input.name} already verified on ${chain}`);
            // There is a rate limit of 5 requests per second
            await (0, utils_2.sleep)(200);
            return;
        }
        else {
            await this.verifyImplementation(chain, input);
        }
        await this.verifyProxy(chain, input);
    }
}
exports.ContractVerifier = ContractVerifier;
//# sourceMappingURL=ContractVerifier.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiProvider = exports.defaultProviderBuilder = void 0;
const debug_1 = require("debug");
const ethers_1 = require("ethers");
const utils_1 = require("@hyperlane-xyz/utils");
const chainMetadata_1 = require("../consts/chainMetadata");
const chains_1 = require("../consts/chains");
const chainMetadataTypes_1 = require("../metadata/chainMetadataTypes");
const objects_1 = require("../utils/objects");
const RetryProvider_1 = require("./RetryProvider");
const DEFAULT_RETRY_OPTIONS = {
    maxRequests: 3,
    baseRetryMs: 250,
};
function defaultProviderBuilder(rpcUrls, network, retryOverride) {
    const createProvider = (r) => {
        const retry = r.retry || retryOverride;
        return retry
            ? new RetryProvider_1.RetryJsonRpcProvider(retry, r.http, network)
            : new ethers_1.providers.StaticJsonRpcProvider(r.http, network);
    };
    if (rpcUrls.length > 1) {
        return new ethers_1.providers.FallbackProvider(rpcUrls.map(createProvider), 1);
    }
    else if (rpcUrls.length === 1) {
        return createProvider(rpcUrls[0]);
    }
    else {
        throw new Error('No RPC URLs provided');
    }
}
exports.defaultProviderBuilder = defaultProviderBuilder;
class MultiProvider {
    /**
     * Create a new MultiProvider with the given chainMetadata,
     * or the SDK's default metadata if not provided
     */
    constructor(chainMetadata = chainMetadata_1.chainMetadata, options = {}) {
        this.metadata = {};
        this.providers = {};
        this.signers = {};
        this.useSharedSigner = false; // A single signer to be used for all chains
        Object.entries(chainMetadata).forEach(([key, cm]) => {
            if (key !== cm.name)
                throw new Error(`Chain name mismatch: Key was ${key}, but name is ${cm.name}`);
            this.addChain(cm);
        });
        this.logger = (0, debug_1.debug)(options?.loggerName || 'hyperlane:MultiProvider');
        this.providerBuilder = options?.providerBuilder || defaultProviderBuilder;
    }
    /**
     * Add a chain to the MultiProvider
     * @throws if chain's name or domain/chain ID collide
     */
    addChain(metadata) {
        if (!(0, chainMetadataTypes_1.isValidChainMetadata)(metadata))
            throw new Error(`Invalid chain metadata for ${metadata.name}`);
        // Ensure no two chains have overlapping names/domainIds/chainIds
        for (const chainMetadata of Object.values(this.metadata)) {
            const { name, chainId, domainId } = chainMetadata;
            if (name == metadata.name)
                throw new Error(`Duplicate chain name: ${name}`);
            // Chain and Domain Ids should be globally unique
            const idCollision = chainId == metadata.chainId ||
                domainId == metadata.chainId ||
                (metadata.domainId &&
                    (chainId == metadata.domainId || domainId === metadata.domainId));
            if (idCollision)
                throw new Error(`Chain/Domain id collision: ${name} and ${metadata.name}`);
        }
        this.metadata[metadata.name] = metadata;
        if (this.useSharedSigner) {
            const signers = Object.values(this.signers);
            if (signers.length > 0) {
                this.setSharedSigner(signers[0]);
            }
        }
    }
    /**
     * Get the metadata for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    tryGetChainMetadata(chainNameOrId) {
        let chainMetadata;
        if (typeof chainNameOrId === 'string') {
            chainMetadata = this.metadata[chainNameOrId];
        }
        else if (typeof chainNameOrId === 'number') {
            chainMetadata = Object.values(this.metadata).find((m) => m.chainId === chainNameOrId || m.domainId === chainNameOrId);
        }
        return chainMetadata || null;
    }
    /**
     * Get the metadata for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getChainMetadata(chainNameOrId) {
        const chainMetadata = this.tryGetChainMetadata(chainNameOrId);
        if (!chainMetadata)
            throw new Error(`No chain metadata set for ${chainNameOrId}`);
        return chainMetadata;
    }
    /**
     * Get the name for a given chain name, chain id, or domain id
     */
    tryGetChainName(chainNameOrId) {
        return this.tryGetChainMetadata(chainNameOrId)?.name ?? null;
    }
    /**
     * Get the name for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getChainName(chainNameOrId) {
        return this.getChainMetadata(chainNameOrId).name;
    }
    /**
     * Get the names for all chains known to this MultiProvider
     */
    getKnownChainNames() {
        return Object.keys(this.metadata);
    }
    /**
     * Get the id for a given chain name, chain id, or domain id
     */
    tryGetChainId(chainNameOrId) {
        return this.tryGetChainMetadata(chainNameOrId)?.chainId ?? null;
    }
    /**
     * Get the id for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getChainId(chainNameOrId) {
        return this.getChainMetadata(chainNameOrId).chainId;
    }
    /**
     * Get the ids for all chains known to this MultiProvider
     */
    getKnownChainIds() {
        return Object.values(this.metadata).map((c) => c.chainId);
    }
    /**
     * Get the domain id for a given chain name, chain id, or domain id
     */
    tryGetDomainId(chainNameOrId) {
        const metadata = this.tryGetChainMetadata(chainNameOrId);
        return metadata?.domainId ?? metadata?.chainId ?? null;
    }
    /**
     * Get the domain id for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getDomainId(chainNameOrId) {
        const metadata = this.getChainMetadata(chainNameOrId);
        return (0, chainMetadataTypes_1.getDomainId)(metadata);
    }
    /**
     * Get the domain ids for a list of chain names, chain ids, or domain ids
     * @throws if any chain's metadata has not been set
     */
    getDomainIds(chainNamesOrIds) {
        return chainNamesOrIds.map((c) => this.getDomainId(c));
    }
    /**
     * Get the ids for all chains known to this MultiProvider
     */
    getKnownDomainIds() {
        return this.getKnownChainNames().map(this.getDomainId);
    }
    /**
     * Get an Ethers provider for a given chain name, chain id, or domain id
     */
    tryGetProvider(chainNameOrId) {
        const metadata = this.tryGetChainMetadata(chainNameOrId);
        if (!metadata)
            return null;
        const { name, chainId, rpcUrls } = metadata;
        if (this.providers[name])
            return this.providers[name];
        if (chains_1.TestChains.includes(name)) {
            this.providers[name] = new ethers_1.providers.JsonRpcProvider('http://127.0.0.1:8545', 31337);
        }
        else if (rpcUrls.length) {
            this.providers[name] = this.providerBuilder(rpcUrls, chainId, DEFAULT_RETRY_OPTIONS);
        }
        else {
            return null;
        }
        return this.providers[name];
    }
    /**
     * Get an Ethers provider for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getProvider(chainNameOrId) {
        const provider = this.tryGetProvider(chainNameOrId);
        if (!provider)
            throw new Error(`No chain metadata set for ${chainNameOrId}`);
        return provider;
    }
    /**
     * Sets an Ethers provider for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    setProvider(chainNameOrId, provider) {
        const chainName = this.getChainName(chainNameOrId);
        this.providers[chainName] = provider;
        const signer = this.signers[chainName];
        if (signer && signer.provider) {
            this.setSigner(chainName, signer.connect(provider));
        }
        return provider;
    }
    /**
     * Sets Ethers providers for a set of chains
     * @throws if chain's metadata has not been set
     */
    setProviders(providers) {
        for (const chain of Object.keys(providers)) {
            const chainName = this.getChainName(chain);
            this.providers[chainName] = providers[chain];
        }
    }
    /**
     * Get an Ethers signer for a given chain name, chain id, or domain id
     * If signer is not yet connected, it will be connected
     */
    tryGetSigner(chainNameOrId) {
        const chainName = this.tryGetChainName(chainNameOrId);
        if (!chainName)
            return null;
        const signer = this.signers[chainName];
        if (!signer)
            return null;
        if (signer.provider)
            return signer;
        // Auto-connect the signer for convenience
        const provider = this.tryGetProvider(chainName);
        return provider ? signer.connect(provider) : signer;
    }
    /**
     * Get an Ethers signer for a given chain name, chain id, or domain id
     * If signer is not yet connected, it will be connected
     * @throws if chain's metadata or signer has not been set
     */
    getSigner(chainNameOrId) {
        const signer = this.tryGetSigner(chainNameOrId);
        if (!signer)
            throw new Error(`No chain signer set for ${chainNameOrId}`);
        return signer;
    }
    /**
     * Get an Ethers signer for a given chain name, chain id, or domain id
     * @throws if chain's metadata or signer has not been set
     */
    async getSignerAddress(chainNameOrId) {
        const signer = this.getSigner(chainNameOrId);
        const address = await signer.getAddress();
        return address;
    }
    /**
     * Sets an Ethers Signer for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set or shared signer has already been set
     */
    setSigner(chainNameOrId, signer) {
        if (this.useSharedSigner) {
            throw new Error('MultiProvider already set to use a shared signer');
        }
        const chainName = this.getChainName(chainNameOrId);
        this.signers[chainName] = signer;
        if (signer.provider && !this.providers[chainName]) {
            this.providers[chainName] = signer.provider;
        }
        return signer;
    }
    /**
     * Sets Ethers Signers for a set of chains
     * @throws if chain's metadata has not been set or shared signer has already been set
     */
    setSigners(signers) {
        if (this.useSharedSigner) {
            throw new Error('MultiProvider already set to use a shared signer');
        }
        for (const chain of Object.keys(signers)) {
            const chainName = this.getChainName(chain);
            this.signers[chainName] = signers[chain];
        }
    }
    /**
     * Gets the Signer if it's been set, otherwise the provider
     */
    tryGetSignerOrProvider(chainNameOrId) {
        return (this.tryGetSigner(chainNameOrId) || this.tryGetProvider(chainNameOrId));
    }
    /**
     * Gets the Signer if it's been set, otherwise the provider
     * @throws if chain metadata has not been set
     */
    getSignerOrProvider(chainNameOrId) {
        return this.tryGetSigner(chainNameOrId) || this.getProvider(chainNameOrId);
    }
    /**
     * Sets Ethers Signers to be used for all chains
     * Any subsequent calls to getSigner will return given signer
     * Setting sharedSigner to null clears all signers
     */
    setSharedSigner(sharedSigner) {
        if (!sharedSigner) {
            this.useSharedSigner = false;
            this.signers = {};
            return null;
        }
        this.useSharedSigner = true;
        for (const chain of this.getKnownChainNames()) {
            this.signers[chain] = sharedSigner;
        }
        return sharedSigner;
    }
    /**
     * Create a new MultiProvider from the intersection
     * of current's chains and the provided chain list
     */
    intersect(chains, throwIfNotSubset = false) {
        const ownChains = this.getKnownChainNames();
        const intersection = [];
        for (const chain of chains) {
            if (ownChains.includes(chain)) {
                intersection.push(chain);
            }
            else if (throwIfNotSubset) {
                throw new Error(`MultiProvider#intersect: chains specified ${chain}, but ownChains did not include it`);
            }
        }
        if (!intersection.length) {
            throw new Error(`No chains shared between MultiProvider and list (${ownChains} and ${chains})`);
        }
        const intersectionMetadata = (0, objects_1.pick)(this.metadata, intersection);
        const intersectionProviders = (0, objects_1.pick)(this.providers, intersection);
        const intersectionSigners = (0, objects_1.pick)(this.signers, intersection);
        const multiProvider = new MultiProvider(intersectionMetadata);
        multiProvider.setProviders(intersectionProviders);
        multiProvider.setSigners(intersectionSigners);
        return { intersection, multiProvider };
    }
    /**
     * Get chain names excluding given chain name
     */
    getRemoteChains(name) {
        return utils_1.utils.exclude(name, this.getKnownChainNames());
    }
    /**
     * Get an RPC URL for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getRpcUrl(chainNameOrId) {
        const { rpcUrls } = this.getChainMetadata(chainNameOrId);
        if (!rpcUrls?.length || !rpcUrls[0].http)
            throw new Error(`No RPC URl configured for ${chainNameOrId}`);
        return rpcUrls[0].http;
    }
    /**
     * Get a block explorer URL for a given chain name, chain id, or domain id
     */
    tryGetExplorerUrl(chainNameOrId) {
        const explorers = this.tryGetChainMetadata(chainNameOrId)?.blockExplorers;
        if (!explorers?.length)
            return null;
        return explorers[0].url;
    }
    /**
     * Get a block explorer URL for a given chain name, chain id, or domain id
     * @throws if chain's metadata or block explorer data has no been set
     */
    getExplorerUrl(chainNameOrId) {
        const url = this.tryGetExplorerUrl(chainNameOrId);
        if (!url)
            throw new Error(`No explorer url set for ${chainNameOrId}`);
        return url;
    }
    /**
     * Get a block explorer's API URL for a given chain name, chain id, or domain id
     */
    tryGetExplorerApiUrl(chainNameOrId) {
        const explorers = this.tryGetChainMetadata(chainNameOrId)?.blockExplorers;
        if (!explorers?.length || !explorers[0].apiUrl)
            return null;
        const { apiUrl, apiKey } = explorers[0];
        if (!apiKey)
            return apiUrl;
        const url = new URL(apiUrl);
        url.searchParams.set('apikey', apiKey);
        return url.toString();
    }
    /**
     * Get a block explorer API URL for a given chain name, chain id, or domain id
     * @throws if chain's metadata or block explorer data has no been set
     */
    getExplorerApiUrl(chainNameOrId) {
        const url = this.tryGetExplorerApiUrl(chainNameOrId);
        if (!url)
            throw new Error(`No explorer api url set for ${chainNameOrId}`);
        return url;
    }
    /**
     * Get a block explorer URL for given chain's tx
     */
    tryGetExplorerTxUrl(chainNameOrId, response) {
        const baseUrl = this.tryGetExplorerUrl(chainNameOrId);
        return baseUrl ? `${baseUrl}/tx/${response.hash}` : null;
    }
    /**
     * Get a block explorer URL for given chain's tx
     * @throws if chain's metadata or block explorer data has no been set
     */
    getExplorerTxUrl(chainNameOrId, response) {
        return `${this.getExplorerUrl(chainNameOrId)}/tx/${response.hash}`;
    }
    /**
     * Get a block explorer URL for given chain's address
     */
    async tryGetExplorerAddressUrl(chainNameOrId, address) {
        const baseUrl = this.tryGetExplorerUrl(chainNameOrId);
        if (!baseUrl)
            return null;
        if (address)
            return `${baseUrl}/address/${address}`;
        const signer = this.tryGetSigner(chainNameOrId);
        if (!signer)
            return null;
        return `${baseUrl}/address/${await signer.getAddress()}`;
    }
    /**
     * Get a block explorer URL for given chain's address
     * @throws if chain's metadata, signer, or block explorer data has no been set
     */
    async getExplorerAddressUrl(chainNameOrId, address) {
        const url = await this.tryGetExplorerAddressUrl(chainNameOrId, address);
        if (!url)
            throw new Error(`Missing data for address url for ${chainNameOrId}`);
        return url;
    }
    /**
     * Get the transaction overrides for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getTransactionOverrides(chainNameOrId) {
        return this.getChainMetadata(chainNameOrId)?.transactionOverrides ?? {};
    }
    /**
     * Wait for given tx to be confirmed
     * @throws if chain's metadata or signer has not been set or tx fails
     */
    async handleTx(chainNameOrId, tx) {
        const confirmations = this.getChainMetadata(chainNameOrId).blocks?.confirmations || 1;
        const response = await tx;
        const txUrl = this.tryGetExplorerTxUrl(chainNameOrId, response);
        this.logger(`Pending ${txUrl || response.hash} (waiting ${confirmations} blocks for confirmation)`);
        return response.wait(confirmations);
    }
    /**
     * Populate a transaction's fields using signer address and overrides
     * @throws if chain's metadata has not been set or tx fails
     */
    async prepareTx(chainNameOrId, tx, from) {
        const txFrom = from ? from : await this.getSignerAddress(chainNameOrId);
        const overrides = this.getTransactionOverrides(chainNameOrId);
        return {
            ...tx,
            from: txFrom,
            ...overrides,
        };
    }
    /**
     * Estimate gas for given tx
     * @throws if chain's metadata has not been set or tx fails
     */
    async estimateGas(chainNameOrId, tx, from) {
        const txReq = {
            ...(await this.prepareTx(chainNameOrId, tx, from)),
            // Reset any tx request params that may have an unintended effect on gas estimation
            gasLimit: undefined,
            gasPrice: undefined,
            maxPriorityFeePerGas: undefined,
            maxFeePerGas: undefined,
        };
        const provider = this.getProvider(chainNameOrId);
        return provider.estimateGas(txReq);
    }
    /**
     * Send a transaction and wait for confirmation
     * @throws if chain's metadata or signer has not been set or tx fails
     */
    async sendTransaction(chainNameOrId, tx) {
        const txReq = await this.prepareTx(chainNameOrId, tx);
        const signer = this.getSigner(chainNameOrId);
        const response = await signer.sendTransaction(txReq);
        this.logger(`Sent tx ${response.hash}`);
        return this.handleTx(chainNameOrId, response);
    }
    /**
     * Run given function on all known chains
     */
    mapKnownChains(fn) {
        const result = {};
        for (const chain of this.getKnownChainNames()) {
            result[chain] = fn(chain);
        }
        return result;
    }
    /**
     * Creates a MultiProvider using the given signer for all test networks
     */
    static createTestMultiProvider(params = {}, chains = chains_1.TestChains) {
        const { signer, provider } = params;
        const chainMetadata = (0, objects_1.pick)(chainMetadata_1.chainMetadata, chains);
        const mp = new MultiProvider(chainMetadata);
        if (signer) {
            mp.setSharedSigner(signer);
        }
        const _provider = provider || signer?.provider;
        if (_provider) {
            const providerMap = {};
            chains.forEach((t) => (providerMap[t] = _provider));
            mp.setProviders(providerMap);
        }
        return mp;
    }
}
exports.MultiProvider = MultiProvider;
//# sourceMappingURL=MultiProvider.js.map
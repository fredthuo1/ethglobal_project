"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProxiedRouterDeployer = void 0;
const ethers_1 = require("ethers");
const core_1 = require("@hyperlane-xyz/core");
const utils_1 = require("@hyperlane-xyz/utils/dist/src/utils");
const HyperlaneRouterDeployer_1 = require("./HyperlaneRouterDeployer");
class ProxiedRouterDeployer extends HyperlaneRouterDeployer_1.HyperlaneRouterDeployer {
    router(contracts) {
        return contracts[this.routerContractName];
    }
    async deployContracts(chain, config) {
        const proxyAdmin = await this.deployContractFromFactory(chain, this.factories.proxyAdmin, 'proxyAdmin', []);
        let timelockController;
        let adminOwner;
        if (config.timelock) {
            timelockController = await this.deployTimelock(chain, config.timelock);
            adminOwner = timelockController.address;
        }
        else {
            timelockController = core_1.TimelockController__factory.connect(ethers_1.ethers.constants.AddressZero, this.multiProvider.getProvider(chain));
            adminOwner = config.owner;
        }
        await super.runIfOwner(chain, proxyAdmin, async () => {
            this.logger(`Checking ownership of proxy admin to ${adminOwner}`);
            if (!(0, utils_1.eqAddress)(await proxyAdmin.owner(), adminOwner)) {
                this.logger(`Transferring ownership of proxy admin to ${adminOwner}`);
                return this.multiProvider.handleTx(chain, proxyAdmin.transferOwnership(adminOwner));
            }
            return;
        });
        const proxiedRouter = await this.deployProxiedContract(chain, this.routerContractName, proxyAdmin.address, await this.constructorArgs(chain, config), await this.initializeArgs(chain, config));
        return {
            [this.routerContractName]: proxiedRouter,
            proxyAdmin,
            timelockController,
        };
    }
}
exports.ProxiedRouterDeployer = ProxiedRouterDeployer;
//# sourceMappingURL=ProxiedRouterDeployer.js.map
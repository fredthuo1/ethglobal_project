"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneRouterChecker = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("@hyperlane-xyz/utils");
const HyperlaneAppChecker_1 = require("../deploy/HyperlaneAppChecker");
const types_1 = require("./types");
class HyperlaneRouterChecker extends HyperlaneAppChecker_1.HyperlaneAppChecker {
    async checkChain(chain) {
        await this.checkHyperlaneConnectionClient(chain);
        await this.checkEnrolledRouters(chain);
        await super.checkOwnership(chain, this.configMap[chain].owner);
    }
    async checkHyperlaneConnectionClient(chain) {
        const router = this.app.router(this.app.getContracts(chain));
        const checkConnectionClientProperty = async (property, violationType) => {
            const actual = await router[property]();
            // TODO: check for IsmConfig
            const value = this.configMap[chain][property];
            if (value && typeof value === 'object')
                throw new Error('ISM as object unimplemented');
            const expected = value && typeof value === 'string'
                ? value
                : ethers_1.ethers.constants.AddressZero;
            if (!utils_1.utils.eqAddress(actual, expected)) {
                const violation = {
                    chain,
                    type: violationType,
                    contract: router,
                    actual,
                    expected,
                };
                this.addViolation(violation);
            }
        };
        await checkConnectionClientProperty('mailbox', types_1.ConnectionClientViolationType.Mailbox);
        await checkConnectionClientProperty('interchainGasPaymaster', types_1.ConnectionClientViolationType.InterchainGasPaymaster);
        await checkConnectionClientProperty('interchainSecurityModule', types_1.ConnectionClientViolationType.InterchainSecurityModule);
    }
    async checkEnrolledRouters(chain) {
        const router = this.app.router(this.app.getContracts(chain));
        await Promise.all(this.app.remoteChains(chain).map(async (remoteChain) => {
            const remoteRouter = this.app.router(this.app.getContracts(remoteChain));
            const remoteDomainId = this.multiProvider.getDomainId(remoteChain);
            const address = await router.routers(remoteDomainId);
            utils_1.utils.assert(address === utils_1.utils.addressToBytes32(remoteRouter.address));
        }));
    }
}
exports.HyperlaneRouterChecker = HyperlaneRouterChecker;
//# sourceMappingURL=HyperlaneRouterChecker.js.map
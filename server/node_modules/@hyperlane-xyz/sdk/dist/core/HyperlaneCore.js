"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneCore = void 0;
const core_1 = require("@hyperlane-xyz/core");
const utils_1 = require("@hyperlane-xyz/utils");
const HyperlaneApp_1 = require("../HyperlaneApp");
const environments_1 = require("../consts/environments");
const contracts_1 = require("../contracts");
const contracts_2 = require("./contracts");
class HyperlaneCore extends HyperlaneApp_1.HyperlaneApp {
    static fromEnvironment(env, multiProvider) {
        const envAddresses = environments_1.hyperlaneEnvironments[env];
        if (!envAddresses) {
            throw new Error(`No addresses found for ${env}`);
        }
        return HyperlaneCore.fromAddressesMap(envAddresses, multiProvider);
    }
    static fromAddressesMap(addressesMap, multiProvider) {
        const helper = (0, contracts_1.appFromAddressesMapHelper)(addressesMap, contracts_2.coreFactories, multiProvider);
        return new HyperlaneCore(helper.contractsMap, helper.multiProvider);
    }
    getDestination(message) {
        const destinationChain = this.multiProvider.getChainName(message.parsed.destination);
        const mailbox = this.getContracts(destinationChain).mailbox;
        return { destinationChain, mailbox };
    }
    waitForProcessReceipt(message) {
        const id = utils_1.utils.messageId(message.message);
        const { destinationChain, mailbox } = this.getDestination(message);
        const filter = mailbox.filters.ProcessId(id);
        return new Promise((resolve, reject) => {
            mailbox.once(filter, (emittedId, event) => {
                if (id !== emittedId) {
                    reject(`Expected message id ${id} but got ${emittedId}`);
                }
                resolve(this.multiProvider.handleTx(destinationChain, event.getTransaction()));
            });
        });
    }
    async waitForMessageWasProcessed(message) {
        const id = utils_1.utils.messageId(message.message);
        const { mailbox } = this.getDestination(message);
        await utils_1.utils.pollAsync(async () => {
            const delivered = await mailbox.delivered(id);
            if (!delivered) {
                throw new Error(`Message ${id} not yet processed`);
            }
        });
        return;
    }
    waitForMessageProcessing(sourceTx) {
        const messages = HyperlaneCore.getDispatchedMessages(sourceTx);
        return Promise.all(messages.map((msg) => this.waitForProcessReceipt(msg)));
    }
    async waitForMessageProcessed(sourceTx) {
        const messages = HyperlaneCore.getDispatchedMessages(sourceTx);
        await Promise.all(messages.map((msg) => this.waitForMessageWasProcessed(msg)));
    }
    // Redundant with static method but keeping for backwards compatibility
    getDispatchedMessages(sourceTx) {
        return HyperlaneCore.getDispatchedMessages(sourceTx);
    }
    static getDispatchedMessages(sourceTx) {
        const mailbox = core_1.Mailbox__factory.createInterface();
        const dispatchLogs = sourceTx.logs
            .map((log) => {
            try {
                return mailbox.parseLog(log);
            }
            catch (e) {
                return undefined;
            }
        })
            .filter((log) => !!log && log.name === 'Dispatch');
        return dispatchLogs.map((log) => {
            const message = log.args['message'];
            const parsed = utils_1.utils.parseMessage(message);
            const id = utils_1.utils.messageId(message);
            return { id, message, parsed };
        });
    }
}
exports.HyperlaneCore = HyperlaneCore;
//# sourceMappingURL=HyperlaneCore.js.map
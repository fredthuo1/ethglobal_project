"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("@nomiclabs/hardhat-ethers");
require("@nomiclabs/hardhat-waffle");
const chai_1 = require("chai");
const hardhat_1 = require("hardhat");
const core_1 = require("@hyperlane-xyz/core");
const utils_1 = require("@hyperlane-xyz/utils");
const chains_1 = require("../consts/chains");
const MultiProvider_1 = require("../providers/MultiProvider");
const TestCoreDeployer_1 = require("./TestCoreDeployer");
const localChain = chains_1.Chains.test1;
const remoteChain = chains_1.Chains.test2;
const message = '0xdeadbeef';
describe('TestCoreDeployer', async () => {
    let testCoreApp, localMailbox, remoteMailbox, dispatchReceipt;
    beforeEach(async () => {
        const [signer] = await hardhat_1.ethers.getSigners();
        const multiProvider = MultiProvider_1.MultiProvider.createTestMultiProvider({ signer });
        const deployer = new TestCoreDeployer_1.TestCoreDeployer(multiProvider);
        testCoreApp = await deployer.deployApp();
        const recipient = await new core_1.TestRecipient__factory(signer).deploy();
        localMailbox = testCoreApp.getContracts(localChain).mailbox;
        const dispatchResponse = localMailbox.dispatch(multiProvider.getDomainId(remoteChain), utils_1.utils.addressToBytes32(recipient.address), message);
        await (0, chai_1.expect)(dispatchResponse).to.emit(localMailbox, 'Dispatch');
        dispatchReceipt = await testCoreApp.multiProvider.handleTx(localChain, dispatchResponse);
        remoteMailbox = testCoreApp.getContracts(remoteChain).mailbox;
        await (0, chai_1.expect)(remoteMailbox.dispatch(multiProvider.getDomainId(localChain), utils_1.utils.addressToBytes32(recipient.address), message)).to.emit(remoteMailbox, 'Dispatch');
    });
    it('processes outbound messages for a single domain', async () => {
        const responses = await testCoreApp.processOutboundMessages(localChain);
        (0, chai_1.expect)(responses.get(remoteChain).length).to.equal(1);
    });
    it('processes outbound messages for two domains', async () => {
        const localResponses = await testCoreApp.processOutboundMessages(localChain);
        (0, chai_1.expect)(localResponses.get(remoteChain).length).to.equal(1);
        const remoteResponses = await testCoreApp.processOutboundMessages(remoteChain);
        (0, chai_1.expect)(remoteResponses.get(localChain).length).to.equal(1);
    });
    it('processes all messages', async () => {
        const responses = await testCoreApp.processMessages();
        (0, chai_1.expect)(responses.get(localChain).get(remoteChain).length).to.equal(1);
        (0, chai_1.expect)(responses.get(remoteChain).get(localChain).length).to.equal(1);
    });
    it('waits on message processing receipts', async () => {
        const [receipts] = await Promise.all([
            testCoreApp.waitForMessageProcessing(dispatchReceipt),
            testCoreApp.processOutboundMessages(localChain),
        ]);
        (0, chai_1.expect)(receipts).to.have.length(1);
    });
});
//# sourceMappingURL=testHyperlaneDeploy.hardhat-test.js.map
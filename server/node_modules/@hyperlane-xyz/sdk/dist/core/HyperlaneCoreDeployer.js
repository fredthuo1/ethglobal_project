"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneCoreDeployer = void 0;
const debug_1 = __importDefault(require("debug"));
const ethers_1 = require("ethers");
const core_1 = require("@hyperlane-xyz/core");
const HyperlaneDeployer_1 = require("../deploy/HyperlaneDeployer");
const contracts_1 = require("./contracts");
class HyperlaneCoreDeployer extends HyperlaneDeployer_1.HyperlaneDeployer {
    constructor(multiProvider, ismFactory) {
        super(multiProvider, contracts_1.coreFactories, {
            logger: (0, debug_1.default)('hyperlane:CoreDeployer'),
            chainTimeoutMs: 1000 * 60 * 10, // 10 minutes
        });
        this.ismFactory = ismFactory;
        this.startingBlockNumbers = {};
    }
    async deployMailbox(chain, ismConfig, proxyAdmin, owner) {
        const cachedMailbox = this.readCache(chain, this.factories.mailbox, 'mailbox');
        if (cachedMailbox) {
            // let checker/governor handle cached mailbox default ISM configuration
            // TODO: check if config matches AND deployer is owner?
            return cachedMailbox;
        }
        const defaultIsmAddress = await this.deployIsm(chain, ismConfig);
        const domain = this.multiProvider.getDomainId(chain);
        return this.deployProxiedContract(chain, 'mailbox', proxyAdmin, [domain], [owner, defaultIsmAddress]);
    }
    async deployValidatorAnnounce(chain, mailboxAddress) {
        const validatorAnnounce = await this.deployContract(chain, 'validatorAnnounce', [mailboxAddress]);
        return validatorAnnounce;
    }
    async deployIsm(chain, config) {
        this.logger(`Deploying new ISM to ${chain}`);
        const ism = await this.ismFactory.deploy(chain, config);
        return ism.address;
    }
    async deployContracts(chain, config) {
        if (config.remove) {
            // skip deploying to chains configured to be removed
            return undefined;
        }
        this.startingBlockNumbers[chain] = await this.multiProvider
            .getProvider(chain)
            .getBlockNumber();
        const proxyAdmin = await this.deployContract(chain, 'proxyAdmin', []);
        const mailbox = await this.deployMailbox(chain, config.defaultIsm, proxyAdmin.address, config.owner);
        const validatorAnnounce = await this.deployValidatorAnnounce(chain, mailbox.address);
        let timelockController;
        if (config.upgrade) {
            timelockController = await this.deployTimelock(chain, config.upgrade.timelock);
            await this.transferOwnershipOfContracts(chain, timelockController.address, { proxyAdmin });
        }
        else {
            // mock this for consistent serialization
            timelockController = core_1.TimelockController__factory.connect(ethers_1.ethers.constants.AddressZero, this.multiProvider.getProvider(chain));
            await this.transferOwnershipOfContracts(chain, config.owner, {
                mailbox,
                proxyAdmin,
            });
        }
        return {
            mailbox,
            proxyAdmin,
            timelockController,
            validatorAnnounce,
        };
    }
}
exports.HyperlaneCoreDeployer = HyperlaneCoreDeployer;
//# sourceMappingURL=HyperlaneCoreDeployer.js.map
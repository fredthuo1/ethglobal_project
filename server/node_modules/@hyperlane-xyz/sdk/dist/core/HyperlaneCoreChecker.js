"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneCoreChecker = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("@hyperlane-xyz/utils");
const bytecode_1 = require("../consts/bytecode");
const HyperlaneAppChecker_1 = require("../deploy/HyperlaneAppChecker");
const proxy_1 = require("../deploy/proxy");
const HyperlaneIsmFactory_1 = require("../ism/HyperlaneIsmFactory");
const types_1 = require("./types");
class HyperlaneCoreChecker extends HyperlaneAppChecker_1.HyperlaneAppChecker {
    constructor(multiProvider, app, configMap, ismFactory) {
        super(multiProvider, app, configMap);
        this.ismFactory = ismFactory;
    }
    async checkChain(chain) {
        const config = this.configMap[chain];
        // skip chains that are configured to be removed
        if (config.remove) {
            return;
        }
        await this.checkDomainOwnership(chain);
        await this.checkProxiedContracts(chain);
        await this.checkMailbox(chain);
        await this.checkBytecodes(chain);
        await this.checkValidatorAnnounce(chain);
        if (config.upgrade) {
            await this.checkUpgrade(chain, config.upgrade);
        }
    }
    async checkDomainOwnership(chain) {
        const config = this.configMap[chain];
        let ownableOverrides = {};
        if (config.upgrade) {
            const timelockController = this.app.getAddresses(chain).timelockController;
            ownableOverrides = {
                proxyAdmin: timelockController,
            };
        }
        return this.checkOwnership(chain, config.owner, ownableOverrides);
    }
    async checkMailbox(chain) {
        const contracts = this.app.getContracts(chain);
        const mailbox = contracts.mailbox;
        const localDomain = await mailbox.localDomain();
        utils_1.utils.assert(localDomain === this.multiProvider.getDomainId(chain));
        const actualIsm = await mailbox.defaultIsm();
        const config = this.configMap[chain];
        const matches = await (0, HyperlaneIsmFactory_1.moduleMatchesConfig)(chain, actualIsm, config.defaultIsm, this.ismFactory.multiProvider, this.ismFactory.getContracts(chain));
        if (!matches) {
            const violation = {
                type: types_1.CoreViolationType.Mailbox,
                mailboxType: types_1.MailboxViolationType.DefaultIsm,
                contract: mailbox,
                chain,
                actual: actualIsm,
                expected: config.defaultIsm,
            };
            this.addViolation(violation);
        }
    }
    async checkBytecodes(chain) {
        const contracts = this.app.getContracts(chain);
        const mailbox = contracts.mailbox;
        const localDomain = await mailbox.localDomain();
        const implementation = await (0, proxy_1.proxyImplementation)(this.multiProvider.getProvider(chain), mailbox.address);
        await this.checkBytecode(chain, 'Mailbox implementation', implementation, [
            bytecode_1.BytecodeHash.MAILBOX_WITHOUT_LOCAL_DOMAIN_BYTE_CODE_HASH,
            bytecode_1.BytecodeHash.MAILBOX_WITHOUT_LOCAL_DOMAIN_NONZERO_PAUSE_BYTE_CODE_HASH,
        ], (bytecode) => 
        // This is obviously super janky but basically we are searching
        //  for the ocurrences of localDomain in the bytecode and remove
        //  that to compare, but some coincidental ocurrences of
        // localDomain in the bytecode should be not be removed which
        // are just done via an offset guard
        bytecode.replaceAll(ethers_1.utils.defaultAbiCoder
            .encode(['uint32'], [localDomain])
            .slice(2), (match, offset) => (offset > 8000 ? match : '')));
        await this.checkBytecode(chain, 'Mailbox proxy', contracts.mailbox.address, [bytecode_1.BytecodeHash.TRANSPARENT_PROXY_BYTECODE_HASH]);
        await this.checkBytecode(chain, 'ProxyAdmin', contracts.proxyAdmin.address, [bytecode_1.BytecodeHash.PROXY_ADMIN_BYTECODE_HASH]);
    }
    async checkValidatorAnnounce(chain) {
        const validators = new Set();
        const remotes = Object.keys(this.configMap).filter((c) => c !== chain);
        const remoteOriginValidators = remotes.map((remote) => (0, HyperlaneIsmFactory_1.collectValidators)(chain, this.configMap[remote].defaultIsm));
        remoteOriginValidators.map((set) => {
            [...set].map((v) => validators.add(v));
        });
        const validatorAnnounce = this.app.getContracts(chain).validatorAnnounce;
        const announcedValidators = await validatorAnnounce.getAnnouncedValidators();
        [...validators].forEach((validator) => {
            const matches = announcedValidators.filter((x) => utils_1.utils.eqAddress(x, validator));
            if (matches.length == 0) {
                const violation = {
                    type: types_1.CoreViolationType.ValidatorAnnounce,
                    chain,
                    validator,
                    actual: false,
                    expected: true,
                };
                this.addViolation(violation);
            }
        });
    }
}
exports.HyperlaneCoreChecker = HyperlaneCoreChecker;
//# sourceMappingURL=HyperlaneCoreChecker.js.map
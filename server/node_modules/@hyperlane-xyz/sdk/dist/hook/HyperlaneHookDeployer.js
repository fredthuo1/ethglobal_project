"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneHookDeployer = void 0;
const debug_1 = __importDefault(require("debug"));
const core_1 = require("@hyperlane-xyz/core");
const utils_1 = require("@hyperlane-xyz/utils/dist/src/utils");
const HyperlaneDeployer_1 = require("../deploy/HyperlaneDeployer");
const config_1 = require("./config");
const contracts_1 = require("./contracts");
class HyperlaneHookDeployer extends HyperlaneDeployer_1.HyperlaneDeployer {
    constructor(multiProvider) {
        super(multiProvider, contracts_1.hookFactories, {
            logger: (0, debug_1.default)('hyperlane:HookDeployer'),
        });
    }
    async deploy(configMap) {
        let ismContracts;
        let hookContracts;
        // Process ISM configs first
        for (const [chain, config] of Object.entries(configMap)) {
            if ((0, config_1.isISMConfig)(config)) {
                ismContracts = await this.deployContracts(chain, config);
            }
        }
        // Ensure ISM contracts have been deployed
        if (!ismContracts || !ismContracts?.optimismISM) {
            throw new Error('ISM contracts not deployed');
        }
        // Then process hook configs
        for (const [chain, config] of Object.entries(configMap)) {
            if ((0, config_1.isHookConfig)(config)) {
                config.remoteIsm = ismContracts.optimismISM.address;
                this.logger(`Remote ISM address set as ${config.remoteIsm}`);
                hookContracts = await this.deployContracts(chain, config);
            }
        }
        // Ensure hook contracts have been deployed
        if (!hookContracts || !hookContracts?.optimismMessageHook) {
            throw new Error('Hook contracts not deployed');
        }
        const hookAddress = hookContracts.optimismMessageHook.address;
        this.logger(`Setting hook address ${hookAddress} for OptimismISM`);
        await ismContracts.optimismISM.setOptimismHook(hookAddress);
        const deployedContractMap = {
            optimismISM: ismContracts.optimismISM,
            testRecipient: ismContracts.testRecipient,
            optimismMessageHook: hookContracts.optimismMessageHook,
        };
        return deployedContractMap;
    }
    async deployContracts(chain, hookConfig) {
        let optimismISM, optimismMessageHook, testRecipient;
        this.logger(`Deploying ${hookConfig.hookContractType} on ${chain}`);
        if ((0, config_1.isISMConfig)(hookConfig)) {
            optimismISM = await this.deployOptimismISM(chain, hookConfig.nativeBridge);
            testRecipient = await this.deployTestRecipient(chain, optimismISM.address);
            this.logger(`Deployed test recipient on ${chain} at ${(0, utils_1.addressToBytes32)(testRecipient.address)}`);
            return {
                optimismISM,
                testRecipient,
            };
        }
        else if ((0, config_1.isHookConfig)(hookConfig)) {
            optimismMessageHook = await this.deployOptimismMessageHook(chain, hookConfig.destinationDomain, hookConfig.nativeBridge, hookConfig.remoteIsm);
            return {
                optimismMessageHook,
            };
        }
        return {};
    }
    async deployOptimismISM(chain, nativeBridge) {
        const signer = this.multiProvider.getSigner(chain);
        const optimismISM = await new core_1.OptimismISM__factory(signer).deploy(nativeBridge);
        await this.multiProvider.handleTx(chain, optimismISM.deployTransaction);
        this.logger(`Deployed OptimismISM on ${chain} at ${optimismISM.address}`);
        return optimismISM;
    }
    async deployTestRecipient(chain, ism) {
        const signer = this.multiProvider.getSigner(chain);
        const testRecipient = await new core_1.TestRecipient__factory(signer).deploy();
        await this.multiProvider.handleTx(chain, testRecipient.deployTransaction);
        await testRecipient.setInterchainSecurityModule(ism);
        return testRecipient;
    }
    async deployOptimismMessageHook(chain, destinationDomain, nativeBridge, optimismISM) {
        const signer = this.multiProvider.getSigner(chain);
        const optimismMessageHook = await new core_1.OptimismMessageHook__factory(signer).deploy(destinationDomain, nativeBridge, optimismISM);
        await this.multiProvider.handleTx(chain, optimismMessageHook.deployTransaction);
        this.logger(`Deployed OptimismMessageHook on ${chain} at ${optimismMessageHook.address}`);
        return optimismMessageHook;
    }
}
exports.HyperlaneHookDeployer = HyperlaneHookDeployer;
//# sourceMappingURL=HyperlaneHookDeployer.js.map
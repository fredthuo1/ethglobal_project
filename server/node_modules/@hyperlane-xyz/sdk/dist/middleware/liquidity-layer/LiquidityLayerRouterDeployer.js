"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiquidityLayerDeployer = exports.BridgeAdapterType = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("@hyperlane-xyz/utils");
const ProxiedRouterDeployer_1 = require("../../router/ProxiedRouterDeployer");
const objects_1 = require("../../utils/objects");
const contracts_1 = require("./contracts");
var BridgeAdapterType;
(function (BridgeAdapterType) {
    BridgeAdapterType["Circle"] = "Circle";
    BridgeAdapterType["Portal"] = "Portal";
})(BridgeAdapterType || (exports.BridgeAdapterType = BridgeAdapterType = {}));
class LiquidityLayerDeployer extends ProxiedRouterDeployer_1.ProxiedRouterDeployer {
    constructor(multiProvider) {
        super(multiProvider, contracts_1.liquidityLayerFactories);
        this.routerContractName = 'liquidityLayerRouter';
    }
    async constructorArgs(_, __) {
        return [];
    }
    async initializeArgs(chain, config) {
        const owner = await this.multiProvider.getSignerAddress(chain);
        if (typeof config.interchainSecurityModule === 'object') {
            throw new Error('ISM as object unimplemented');
        }
        return [
            config.mailbox,
            config.interchainGasPaymaster,
            config.interchainSecurityModule ?? ethers_1.ethers.constants.AddressZero,
            owner,
        ];
    }
    async enrollRemoteRouters(contractsMap, configMap, foreignRouters) {
        this.logger(`Enroll LiquidityLayerRouters with each other`);
        await super.enrollRemoteRouters(contractsMap, configMap, foreignRouters);
        this.logger(`Enroll CircleBridgeAdapters with each other`);
        // Hack to allow use of super.enrollRemoteRouters
        await super.enrollRemoteRouters((0, objects_1.objMap)((0, objects_1.objFilter)(contractsMap, (_, c) => !!c.circleBridgeAdapter), (_, contracts) => ({
            liquidityLayerRouter: contracts.circleBridgeAdapter,
        })), configMap, foreignRouters);
        this.logger(`Enroll PortalAdapters with each other`);
        // Hack to allow use of super.enrollRemoteRouters
        await super.enrollRemoteRouters((0, objects_1.objMap)((0, objects_1.objFilter)(contractsMap, (_, c) => !!c.portalAdapter), (_, contracts) => ({
            liquidityLayerRouter: contracts.portalAdapter,
        })), configMap, foreignRouters);
    }
    // Custom contract deployment logic can go here
    // If no custom logic is needed, call deployContract for the router
    async deployContracts(chain, config) {
        // This is just the temp owner for contracts, and HyperlaneRouterDeployer#transferOwnership actually sets the configured owner
        const deployer = await this.multiProvider.getSignerAddress(chain);
        const routerContracts = await super.deployContracts(chain, config);
        const bridgeAdapters = {};
        if (config.circle) {
            bridgeAdapters.circleBridgeAdapter = await this.deployCircleBridgeAdapter(chain, config.circle, deployer, routerContracts.liquidityLayerRouter);
        }
        if (config.portal) {
            bridgeAdapters.portalAdapter = await this.deployPortalAdapter(chain, config.portal, deployer, routerContracts.liquidityLayerRouter);
        }
        return {
            ...routerContracts,
            ...bridgeAdapters,
        };
    }
    async deployPortalAdapter(chain, adapterConfig, owner, router) {
        const portalAdapter = await this.deployContract(chain, 'portalAdapter', [], [
            this.multiProvider.getDomainId(chain),
            owner,
            adapterConfig.portalBridgeAddress,
            router.address,
        ]);
        for (const { wormholeDomain, hyperlaneDomain, } of adapterConfig.wormholeDomainMapping) {
            const expectedCircleDomain = await portalAdapter.hyperlaneDomainToWormholeDomain(hyperlaneDomain);
            if (expectedCircleDomain === wormholeDomain)
                continue;
            this.logger(`Set wormhole domain ${wormholeDomain} for hyperlane domain ${hyperlaneDomain}`);
            await this.runIfOwner(chain, portalAdapter, () => this.multiProvider.handleTx(chain, portalAdapter.addDomain(hyperlaneDomain, wormholeDomain)));
        }
        if (!utils_1.utils.eqAddress(await router.liquidityLayerAdapters('Portal'), portalAdapter.address)) {
            this.logger('Set Portal as LiquidityLayerAdapter on Router');
            await this.runIfOwner(chain, portalAdapter, () => this.multiProvider.handleTx(chain, router.setLiquidityLayerAdapter(adapterConfig.type, portalAdapter.address)));
        }
        return portalAdapter;
    }
    async deployCircleBridgeAdapter(chain, adapterConfig, owner, router) {
        const circleBridgeAdapter = await this.deployContract(chain, 'circleBridgeAdapter', [], [
            owner,
            adapterConfig.tokenMessengerAddress,
            adapterConfig.messageTransmitterAddress,
            router.address,
        ]);
        if (!utils_1.utils.eqAddress(await circleBridgeAdapter.tokenSymbolToAddress('USDC'), adapterConfig.usdcAddress)) {
            this.logger(`Set USDC token contract`);
            await this.runIfOwner(chain, circleBridgeAdapter, () => this.multiProvider.handleTx(chain, circleBridgeAdapter.addToken(adapterConfig.usdcAddress, 'USDC')));
        }
        // Set domain mappings
        for (const { circleDomain, hyperlaneDomain, } of adapterConfig.circleDomainMapping) {
            const expectedCircleDomain = await circleBridgeAdapter.hyperlaneDomainToCircleDomain(hyperlaneDomain);
            if (expectedCircleDomain === circleDomain)
                continue;
            this.logger(`Set circle domain ${circleDomain} for hyperlane domain ${hyperlaneDomain}`);
            await this.runIfOwner(chain, circleBridgeAdapter, () => this.multiProvider.handleTx(chain, circleBridgeAdapter.addDomain(hyperlaneDomain, circleDomain)));
        }
        if (!utils_1.utils.eqAddress(await router.liquidityLayerAdapters('Circle'), circleBridgeAdapter.address)) {
            this.logger('Set Circle as LiquidityLayerAdapter on Router');
            await this.runIfOwner(chain, circleBridgeAdapter, () => this.multiProvider.handleTx(chain, router.setLiquidityLayerAdapter(adapterConfig.type, circleBridgeAdapter.address)));
        }
        return circleBridgeAdapter;
    }
}
exports.LiquidityLayerDeployer = LiquidityLayerDeployer;
//# sourceMappingURL=LiquidityLayerRouterDeployer.js.map
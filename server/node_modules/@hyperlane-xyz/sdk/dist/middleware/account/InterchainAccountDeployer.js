"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InterchainAccountDeployer = void 0;
const ethers_1 = require("ethers");
const ProxiedRouterDeployer_1 = require("../../router/ProxiedRouterDeployer");
const contracts_1 = require("./contracts");
class InterchainAccountDeployer extends ProxiedRouterDeployer_1.ProxiedRouterDeployer {
    constructor(multiProvider) {
        super(multiProvider, contracts_1.interchainAccountFactories);
        this.routerContractName = 'interchainAccountRouter';
    }
    async constructorArgs(chain, __) {
        const localDomain = this.multiProvider.getDomainId(chain);
        return [localDomain];
    }
    async initializeArgs(chain, config) {
        const owner = await this.multiProvider.getSignerAddress(chain);
        if (typeof config.interchainSecurityModule === 'object') {
            throw new Error('ISM as object unimplemented');
        }
        return [
            config.mailbox,
            config.interchainGasPaymaster,
            config.interchainSecurityModule ?? ethers_1.ethers.constants.AddressZero,
            owner,
        ];
    }
    async deployContracts(chain, config) {
        if (config.interchainSecurityModule) {
            throw new Error('Configuration of ISM not supported in ICA deployer');
        }
        const interchainAccountIsm = await this.deployContract(chain, 'interchainAccountIsm', [config.mailbox]);
        const modifiedConfig = {
            ...config,
            interchainSecurityModule: interchainAccountIsm.address,
        };
        const contracts = await super.deployContracts(chain, modifiedConfig);
        return {
            ...contracts,
            interchainAccountIsm,
        };
    }
}
exports.InterchainAccountDeployer = InterchainAccountDeployer;
//# sourceMappingURL=InterchainAccountDeployer.js.map
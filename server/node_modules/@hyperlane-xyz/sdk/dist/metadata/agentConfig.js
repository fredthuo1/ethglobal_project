"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildAgentConfig = exports.buildAgentConfigDeprecated = exports.buildAgentConfigNew = exports.ChainMetadataForAgentSchema = exports.AgentMetadataExtSchema = exports.AgentConnectionType = void 0;
const zod_1 = require("zod");
const deploymentArtifacts_1 = require("./deploymentArtifacts");
/**
 * New agent config shape that extends the existing chain metadata with agent-specific fields.
 */
var AgentConnectionType;
(function (AgentConnectionType) {
    AgentConnectionType["Http"] = "http";
    AgentConnectionType["Ws"] = "ws";
    AgentConnectionType["HttpQuorum"] = "httpQuorum";
    AgentConnectionType["HttpFallback"] = "httpFallback";
})(AgentConnectionType || (exports.AgentConnectionType = AgentConnectionType = {}));
exports.AgentMetadataExtSchema = zod_1.z.object({
    rpcConsensusType: zod_1.z
        .nativeEnum(AgentConnectionType)
        .default(AgentConnectionType.HttpFallback)
        .describe('The consensus type to use when multiple RPCs are configured. `fallback` will use the first RPC that returns a result, `quorum` will require a majority of RPCs to return the same result. Different consumers may choose to default to different values here, i.e. validators may want to default to `quorum` while relayers may want to default to `fallback`.'),
    overrideRpcUrls: zod_1.z
        .string()
        .optional()
        .describe('Used to allow for a comma-separated list of RPC URLs to be specified without a complex `path` in the agent configuration scheme. Agents should check for the existence of this field first and use that in conjunction with `rpcConsensusType` if it exists, otherwise fall back to `rpcUrls`.'),
    index: zod_1.z.object({
        from: zod_1.z
            .number()
            .default(1999)
            .optional()
            .describe('The starting block from which to index events.'),
        chunk: zod_1.z
            .number()
            .default(1000)
            .optional()
            .describe('The number of blocks to index per chunk.'),
    }),
});
exports.ChainMetadataForAgentSchema = deploymentArtifacts_1.ChainMetadataWithArtifactsSchema.merge(exports.AgentMetadataExtSchema);
/**
 * Utilities for generating agent configs from metadata / artifacts.
 */
// Returns the new agent config shape that extends ChainMetadata
function buildAgentConfigNew(chains, multiProvider, addresses, startBlocks) {
    const configs = {};
    for (const chain of [...chains].sort()) {
        const metadata = multiProvider.getChainMetadata(chain);
        const config = {
            ...metadata,
            rpcConsensusType: AgentConnectionType.HttpFallback,
            mailbox: addresses[chain].mailbox,
            interchainGasPaymaster: addresses[chain].interchainGasPaymaster,
            validatorAnnounce: addresses[chain].validatorAnnounce,
            index: {
                from: startBlocks[chain],
            },
        };
        configs[chain] = config;
    }
    return configs;
}
exports.buildAgentConfigNew = buildAgentConfigNew;
// Returns the current (but deprecated) agent config shape.
function buildAgentConfigDeprecated(chains, multiProvider, addresses, startBlocks) {
    const agentConfig = {
        chains: {},
    };
    for (const chain of [...chains].sort()) {
        const metadata = multiProvider.getChainMetadata(chain);
        const chainConfig = {
            name: chain,
            domain: metadata.chainId,
            addresses: {
                mailbox: addresses[chain].mailbox,
                interchainGasPaymaster: addresses[chain].interchainGasPaymaster,
                validatorAnnounce: addresses[chain].validatorAnnounce,
            },
            protocol: metadata.protocol,
            finalityBlocks: metadata.blocks?.reorgPeriod ?? 1,
        };
        chainConfig.index = {
            from: startBlocks[chain],
        };
        agentConfig.chains[chain] = chainConfig;
    }
    return agentConfig;
}
exports.buildAgentConfigDeprecated = buildAgentConfigDeprecated;
function buildAgentConfig(chains, multiProvider, addresses, startBlocks) {
    return {
        ...buildAgentConfigNew(chains, multiProvider, addresses, startBlocks),
        ...buildAgentConfigDeprecated(chains, multiProvider, addresses, startBlocks),
    };
}
exports.buildAgentConfig = buildAgentConfig;
//# sourceMappingURL=agentConfig.js.map
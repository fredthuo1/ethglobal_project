"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDomainId = exports.isValidChainMetadata = exports.ChainMetadataSchema = exports.ExplorerFamily = exports.ProtocolSmallestUnit = exports.ProtocolType = void 0;
const zod_1 = require("zod");
var ProtocolType;
(function (ProtocolType) {
    ProtocolType["Ethereum"] = "ethereum";
    ProtocolType["Sealevel"] = "sealevel";
    ProtocolType["Fuel"] = "fuel";
})(ProtocolType || (exports.ProtocolType = ProtocolType = {}));
exports.ProtocolSmallestUnit = {
    [ProtocolType.Ethereum]: 'wei',
    [ProtocolType.Sealevel]: 'lamports',
};
var ExplorerFamily;
(function (ExplorerFamily) {
    ExplorerFamily["Etherscan"] = "etherscan";
    ExplorerFamily["Blockscout"] = "blockscout";
    ExplorerFamily["Other"] = "other";
})(ExplorerFamily || (exports.ExplorerFamily = ExplorerFamily = {}));
/**
 * A collection of useful properties and settings for chains using Hyperlane
 * Specified as a Zod schema
 */
exports.ChainMetadataSchema = zod_1.z.object({
    protocol: zod_1.z
        .nativeEnum(ProtocolType)
        .describe('The type of protocol used by this chain. See ProtocolType for valid values.'),
    chainId: zod_1.z
        .number()
        .positive()
        .describe(`The chainId of the chain. Uses EIP-155 for EVM chains`),
    domainId: zod_1.z
        .number()
        .positive()
        .optional()
        .describe('The domainId of the chain, should generally default to `chainId`. Consumer of `ChainMetadata` should use this value if present, but otherwise fallback to `chainId`.'),
    name: zod_1.z
        .string()
        .regex(/^[a-z]+[a-z0-9]*$/)
        .describe('The unique string identifier of the chain, used as the key in ChainMap dictionaries.'),
    displayName: zod_1.z
        .string()
        .optional()
        .describe('Human-readable name of the chain.'),
    displayNameShort: zod_1.z
        .string()
        .optional()
        .describe('A shorter human-readable name of the chain for use in user interfaces.'),
    logoURI: zod_1.z
        .string()
        .optional()
        .describe('A URI to a logo image for this chain for use in user interfaces.'),
    nativeToken: zod_1.z
        .object({
        name: zod_1.z.string(),
        symbol: zod_1.z.string(),
        decimals: zod_1.z.number().nonnegative(),
    })
        .optional()
        .describe('The metadata of the native token of the chain (e.g. ETH for Ethereum).'),
    rpcUrls: zod_1.z
        .array(zod_1.z.object({
        http: zod_1.z
            .string()
            .url()
            .describe('The HTTP URL of the RPC endpoint (preferably HTTPS).'),
        webSocket: zod_1.z
            .string()
            .optional()
            .describe('The WSS URL if the endpoint also supports websockets.'),
        pagination: zod_1.z
            .object({
            maxBlockRange: zod_1.z
                .number()
                .positive()
                .optional()
                .describe('The maximum range between block numbers for which the RPC can query data'),
            minBlockNumber: zod_1.z
                .number()
                .positive()
                .optional()
                .describe('The absolute minimum block number that this RPC supports.'),
            maxBlockAge: zod_1.z
                .number()
                .positive()
                .optional()
                .describe('The relative different from latest block that this RPC supports.'),
        })
            .optional()
            .describe('Limitations on the block range/age that can be queried.'),
        retry: zod_1.z
            .object({
            maxRequests: zod_1.z
                .number()
                .positive()
                .describe('The maximum number of requests to attempt before failing.'),
            baseRetryMs: zod_1.z
                .number()
                .positive()
                .describe('The base retry delay in milliseconds.'),
        })
            .optional()
            .describe('Default retry settings to be used by a provider such as MultiProvider.'),
    }))
        .nonempty()
        .describe('The list of RPC endpoints for interacting with the chain.'),
    blockExplorers: zod_1.z
        .array(zod_1.z.object({
        name: zod_1.z.string().describe('A human readable name for the explorer.'),
        url: zod_1.z.string().url().describe('The base URL for the explorer.'),
        apiUrl: zod_1.z
            .string()
            .url()
            .describe('The base URL for requests to the explorer API.'),
        apiKey: zod_1.z
            .string()
            .optional()
            .describe('An API key for the explorer (recommended for better reliability).'),
        family: zod_1.z
            .nativeEnum(ExplorerFamily)
            .optional()
            .describe('The type of the block explorer. See ExplorerFamily for valid values.'),
    }))
        .optional()
        .describe('A list of block explorers with data for this chain'),
    blocks: zod_1.z
        .object({
        confirmations: zod_1.z
            .number()
            .describe('Number of blocks to wait before considering a transaction confirmed.'),
        reorgPeriod: zod_1.z
            .number()
            .optional()
            .describe('Number of blocks before a transaction has a near-zero chance of reverting.'),
        estimateBlockTime: zod_1.z
            .number()
            .positive()
            .optional()
            .describe('Rough estimate of time per block in seconds.'),
    })
        .optional()
        .describe('Block settings for the chain/deployment.'),
    transactionOverrides: zod_1.z
        .object({})
        .optional()
        .describe('Properties to include when forming transaction requests.'),
    gasCurrencyCoinGeckoId: zod_1.z
        .string()
        .optional()
        .describe('The ID on CoinGecko of the token used for gas payments.'),
    gnosisSafeTransactionServiceUrl: zod_1.z
        .string()
        .optional()
        .describe('The URL of the gnosis safe transaction service.'),
    isTestnet: zod_1.z
        .boolean()
        .optional()
        .describe('Whether the chain is considered a testnet or a mainnet.'),
});
function isValidChainMetadata(c) {
    return exports.ChainMetadataSchema.safeParse(c).success;
}
exports.isValidChainMetadata = isValidChainMetadata;
function getDomainId(chainMetadata) {
    return chainMetadata.domainId ?? chainMetadata.chainId;
}
exports.getDomainId = getDomainId;
//# sourceMappingURL=chainMetadataTypes.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneIgpChecker = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("@hyperlane-xyz/utils");
const bytecode_1 = require("../consts/bytecode");
const HyperlaneAppChecker_1 = require("../deploy/HyperlaneAppChecker");
const proxy_1 = require("../deploy/proxy");
const types_1 = require("./types");
class HyperlaneIgpChecker extends HyperlaneAppChecker_1.HyperlaneAppChecker {
    async checkChain(chain) {
        await this.checkDomainOwnership(chain);
        await this.checkProxiedContracts(chain);
        await this.checkBytecodes(chain);
        await this.checkOverheadInterchainGasPaymaster(chain);
        await this.checkInterchainGasPaymaster(chain);
        const config = this.configMap[chain];
        if (config.upgrade) {
            await this.checkUpgrade(chain, config.upgrade);
        }
    }
    async checkDomainOwnership(chain) {
        const config = this.configMap[chain];
        const ownableOverrides = {
            storageGasOracle: config.oracleKey,
        };
        if (config.upgrade) {
            const timelockController = this.app.getAddresses(chain).timelockController;
            ownableOverrides['proxyAdmin'] = timelockController;
        }
        await super.checkOwnership(chain, config.owner, ownableOverrides);
    }
    async checkBytecodes(chain) {
        const contracts = this.app.getContracts(chain);
        await this.checkBytecode(chain, 'InterchainGasPaymaster proxy', contracts.interchainGasPaymaster.address, [bytecode_1.BytecodeHash.TRANSPARENT_PROXY_BYTECODE_HASH]);
        const implementation = await (0, proxy_1.proxyImplementation)(this.multiProvider.getProvider(chain), contracts.interchainGasPaymaster.address);
        await this.checkBytecode(chain, 'InterchainGasPaymaster implementation', implementation, [
            bytecode_1.BytecodeHash.INTERCHAIN_GAS_PAYMASTER_BYTECODE_HASH,
            bytecode_1.BytecodeHash.OWNER_INITIALIZABLE_INTERCHAIN_GAS_PAYMASTER_BYTECODE_HASH,
        ]);
        await this.checkBytecode(chain, 'OverheadIGP', contracts.defaultIsmInterchainGasPaymaster.address, [bytecode_1.BytecodeHash.OVERHEAD_IGP_BYTECODE_HASH], (bytecode) => 
        // Remove the address of the wrapped IGP from the bytecode
        bytecode.replaceAll(ethers_1.utils.defaultAbiCoder
            .encode(['address'], [contracts.interchainGasPaymaster.address])
            .slice(2), ''));
    }
    async checkOverheadInterchainGasPaymaster(local) {
        const coreContracts = this.app.getContracts(local);
        const defaultIsmIgp = coreContracts.defaultIsmInterchainGasPaymaster;
        // Construct the violation, updating the actual & expected
        // objects as violations are found.
        // A single violation is used so that only a single `setDestinationGasOverheads`
        // call is generated to set multiple gas overheads.
        const overheadViolation = {
            type: 'InterchainGasPaymaster',
            subType: types_1.IgpViolationType.Overhead,
            contract: defaultIsmIgp,
            chain: local,
            actual: {},
            expected: {},
        };
        const remotes = this.app.remoteChains(local);
        for (const remote of remotes) {
            const expectedOverhead = this.configMap[local].overhead[remote];
            const remoteId = this.multiProvider.getDomainId(remote);
            const existingOverhead = await defaultIsmIgp.destinationGasOverhead(remoteId);
            if (!existingOverhead.eq(expectedOverhead)) {
                const remoteChain = remote;
                overheadViolation.actual[remoteChain] = existingOverhead;
                overheadViolation.expected[remoteChain] =
                    ethers_1.BigNumber.from(expectedOverhead);
            }
        }
        if (Object.keys(overheadViolation.actual).length > 0) {
            this.addViolation(overheadViolation);
        }
    }
    async checkInterchainGasPaymaster(local) {
        const coreContracts = this.app.getContracts(local);
        const igp = coreContracts.interchainGasPaymaster;
        // Construct the violation, updating the actual & expected
        // objects as violations are found.
        // A single violation is used so that only a single `setGasOracles`
        // call is generated to set multiple gas oracles.
        const gasOraclesViolation = {
            type: 'InterchainGasPaymaster',
            subType: types_1.IgpViolationType.GasOracles,
            contract: igp,
            chain: local,
            actual: {},
            expected: {},
        };
        const remotes = this.app.remoteChains(local);
        for (const remote of remotes) {
            const remoteId = this.multiProvider.getDomainId(remote);
            const actualGasOracle = await igp.gasOracles(remoteId);
            const expectedGasOracle = this.getGasOracleAddress(local, remote);
            if (!utils_1.utils.eqAddress(actualGasOracle, expectedGasOracle)) {
                const remoteChain = remote;
                gasOraclesViolation.actual[remoteChain] = actualGasOracle;
                gasOraclesViolation.expected[remoteChain] = expectedGasOracle;
            }
        }
        // Add the violation only if it's been populated with gas oracle inconsistencies
        if (Object.keys(gasOraclesViolation.actual).length > 0) {
            this.addViolation(gasOraclesViolation);
        }
        const actualBeneficiary = await igp.beneficiary();
        const expectedBeneficiary = this.configMap[local].beneficiary;
        if (!utils_1.utils.eqAddress(actualBeneficiary, expectedBeneficiary)) {
            const violation = {
                type: 'InterchainGasPaymaster',
                subType: types_1.IgpViolationType.Beneficiary,
                contract: igp,
                chain: local,
                actual: actualBeneficiary,
                expected: expectedBeneficiary,
            };
            this.addViolation(violation);
        }
    }
    getGasOracleAddress(local, remote) {
        const config = this.configMap[local];
        const gasOracleType = config.gasOracleType[remote];
        if (!gasOracleType) {
            throw Error(`Expected gas oracle type for local ${local} and remote ${remote}`);
        }
        const coreContracts = this.app.getContracts(local);
        switch (gasOracleType) {
            case types_1.GasOracleContractType.StorageGasOracle:
                return coreContracts.storageGasOracle.address;
            default:
                throw Error(`Unsupported gas oracle type ${gasOracleType}`);
        }
    }
}
exports.HyperlaneIgpChecker = HyperlaneIgpChecker;
//# sourceMappingURL=HyperlaneIgpChecker.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneIgpDeployer = void 0;
const debug_1 = __importDefault(require("debug"));
const ethers_1 = require("ethers");
const core_1 = require("@hyperlane-xyz/core");
const utils_1 = require("@hyperlane-xyz/utils");
const HyperlaneDeployer_1 = require("../deploy/HyperlaneDeployer");
const contracts_1 = require("./contracts");
class HyperlaneIgpDeployer extends HyperlaneDeployer_1.HyperlaneDeployer {
    constructor(multiProvider) {
        super(multiProvider, contracts_1.igpFactories, {
            logger: (0, debug_1.default)('hyperlane:IgpDeployer'),
        });
    }
    async deployInterchainGasPaymaster(chain, proxyAdmin, storageGasOracle, config) {
        const owner = config.owner;
        const beneficiary = config.beneficiary;
        const igp = await this.deployProxiedContract(chain, 'interchainGasPaymaster', proxyAdmin.address, [], [owner, beneficiary]);
        const gasOracleConfigsToSet = [];
        const remotes = Object.keys(config.gasOracleType);
        for (const remote of remotes) {
            const remoteId = this.multiProvider.getDomainId(remote);
            const currentGasOracle = await igp.gasOracles(remoteId);
            if (!utils_1.utils.eqAddress(currentGasOracle, storageGasOracle.address)) {
                gasOracleConfigsToSet.push({
                    remoteDomain: remoteId,
                    gasOracle: storageGasOracle.address,
                });
            }
        }
        if (gasOracleConfigsToSet.length > 0) {
            await this.runIfOwner(chain, igp, async () => this.multiProvider.handleTx(chain, igp.setGasOracles(gasOracleConfigsToSet)));
        }
        return igp;
    }
    async deployOverheadIgp(chain, interchainGasPaymasterAddress, config) {
        const overheadInterchainGasPaymaster = await this.deployContract(chain, 'defaultIsmInterchainGasPaymaster', [interchainGasPaymasterAddress]);
        // Only set gas overhead configs if they differ from what's on chain
        const configs = [];
        const remotes = Object.keys(config.overhead);
        for (const remote of remotes) {
            const remoteDomain = this.multiProvider.getDomainId(remote);
            const gasOverhead = config.overhead[remote];
            const existingOverhead = await overheadInterchainGasPaymaster.destinationGasOverhead(remoteDomain);
            if (!existingOverhead.eq(gasOverhead)) {
                configs.push({ domain: remoteDomain, gasOverhead });
            }
        }
        if (configs.length > 0) {
            await this.runIfOwner(chain, overheadInterchainGasPaymaster, () => this.multiProvider.handleTx(chain, overheadInterchainGasPaymaster.setDestinationGasOverheads(configs, this.multiProvider.getTransactionOverrides(chain))));
        }
        return overheadInterchainGasPaymaster;
    }
    async deployStorageGasOracle(chain) {
        return this.deployContract(chain, 'storageGasOracle', []);
    }
    async deployContracts(chain, config) {
        // NB: To share ProxyAdmins with HyperlaneCore, ensure the ProxyAdmin
        // is loaded into the contract cache.
        const proxyAdmin = await this.deployContract(chain, 'proxyAdmin', []);
        let timelockController;
        if (config.upgrade) {
            timelockController = await this.deployTimelock(chain, config.upgrade.timelock);
            await this.transferOwnershipOfContracts(chain, timelockController.address, { proxyAdmin });
        }
        else {
            // mock this for consistent serialization
            timelockController = core_1.TimelockController__factory.connect(ethers_1.ethers.constants.AddressZero, this.multiProvider.getProvider(chain));
            await this.transferOwnershipOfContracts(chain, config.owner, {
                proxyAdmin,
            });
        }
        const storageGasOracle = await this.deployStorageGasOracle(chain);
        const interchainGasPaymaster = await this.deployInterchainGasPaymaster(chain, proxyAdmin, storageGasOracle, config);
        const overheadIgp = await this.deployOverheadIgp(chain, interchainGasPaymaster.address, config);
        await this.transferOwnershipOfContracts(chain, config.owner, {
            overheadIgp,
            interchainGasPaymaster,
        });
        // Configure oracle key for StorageGasOracle separately to keep 'hot'
        // for updating exchange rates regularly
        await this.transferOwnershipOfContracts(chain, config.oracleKey, {
            storageGasOracle,
        });
        return {
            proxyAdmin,
            timelockController,
            storageGasOracle,
            interchainGasPaymaster,
            defaultIsmInterchainGasPaymaster: overheadIgp,
        };
    }
}
exports.HyperlaneIgpDeployer = HyperlaneIgpDeployer;
//# sourceMappingURL=HyperlaneIgpDeployer.js.map
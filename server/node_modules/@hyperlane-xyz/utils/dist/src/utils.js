"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runWithTimeout = exports.setEquality = exports.symmetricDifference = exports.difference = exports.safelyAccessEnvVar = exports.timeout = exports.isCheckpoint = exports.isS3CheckpointWithId = exports.isS3Checkpoint = exports.streamToString = exports.stdDev = exports.mean = exports.sum = exports.median = exports.pollAsync = exports.retryAsync = exports.sleep = exports.domainHash = exports.parseMessage = exports.messageId = exports.formatMessage = exports.formatLegacyMultisigIsmMetadata = exports.parseLegacyMultisigIsmMetadata = exports.formatCallData = exports.bytes32ToAddress = exports.addressToBytes32 = exports.strip0x = exports.ensure0x = exports.eqAddress = exports.deepEquals = exports.assert = exports.exclude = void 0;
const ethers_1 = require("ethers");
function exclude(item, list) {
    return list.filter((i) => i !== item);
}
exports.exclude = exclude;
function assert(predicate, errorMessage) {
    if (!predicate) {
        throw new Error(errorMessage ?? 'Error');
    }
}
exports.assert = assert;
function deepEquals(v1, v2) {
    return JSON.stringify(v1) === JSON.stringify(v2);
}
exports.deepEquals = deepEquals;
function eqAddress(a, b) {
    return ethers_1.ethers.utils.getAddress(a) === ethers_1.ethers.utils.getAddress(b);
}
exports.eqAddress = eqAddress;
const ensure0x = (hexstr) => hexstr.startsWith('0x') ? hexstr : `0x${hexstr}`;
exports.ensure0x = ensure0x;
const strip0x = (hexstr) => hexstr.startsWith('0x') ? hexstr.slice(2) : hexstr;
exports.strip0x = strip0x;
function addressToBytes32(address) {
    return ethers_1.ethers.utils
        .hexZeroPad(ethers_1.ethers.utils.hexStripZeros(address), 32)
        .toLowerCase();
}
exports.addressToBytes32 = addressToBytes32;
function bytes32ToAddress(bytes32) {
    return ethers_1.ethers.utils.getAddress(bytes32.slice(-40));
}
exports.bytes32ToAddress = bytes32ToAddress;
function formatCallData(destinationContract, functionName, functionArgs) {
    return destinationContract.interface.encodeFunctionData(functionName, functionArgs);
}
exports.formatCallData = formatCallData;
const parseLegacyMultisigIsmMetadata = (metadata) => {
    const MERKLE_ROOT_OFFSET = 0;
    const MERKLE_INDEX_OFFSET = 32;
    const ORIGIN_MAILBOX_OFFSET = 36;
    const MERKLE_PROOF_OFFSET = 68;
    const THRESHOLD_OFFSET = 1092;
    const SIGNATURES_OFFSET = 1093;
    const SIGNATURE_LENGTH = 65;
    const buf = Buffer.from(ethers_1.utils.arrayify(metadata));
    const checkpointRoot = ethers_1.utils.hexlify(buf.slice(MERKLE_ROOT_OFFSET, MERKLE_INDEX_OFFSET));
    const checkpointIndex = ethers_1.BigNumber.from(ethers_1.utils.hexlify(buf.slice(MERKLE_INDEX_OFFSET, ORIGIN_MAILBOX_OFFSET))).toNumber();
    const originMailbox = ethers_1.utils.hexlify(buf.slice(ORIGIN_MAILBOX_OFFSET, MERKLE_PROOF_OFFSET));
    const parseBytesArray = (start, count, size) => {
        return [...Array(count).keys()].map((i) => ethers_1.utils.hexlify(buf.slice(start + size * i, start + size * (i + 1))));
    };
    const proof = parseBytesArray(MERKLE_PROOF_OFFSET, 32, 32);
    const threshold = ethers_1.BigNumber.from(ethers_1.utils.hexlify(buf.slice(THRESHOLD_OFFSET, SIGNATURES_OFFSET))).toNumber();
    const signatures = parseBytesArray(SIGNATURES_OFFSET, threshold, SIGNATURE_LENGTH);
    const VALIDATORS_OFFSET = SIGNATURES_OFFSET + threshold * SIGNATURE_LENGTH;
    const addressesCount = buf.slice(VALIDATORS_OFFSET).length / 32;
    const validators = parseBytesArray(VALIDATORS_OFFSET, addressesCount, 32);
    return {
        checkpointRoot,
        checkpointIndex,
        originMailbox,
        proof,
        signatures,
        validators,
    };
};
exports.parseLegacyMultisigIsmMetadata = parseLegacyMultisigIsmMetadata;
const formatLegacyMultisigIsmMetadata = (metadata) => {
    return ethers_1.ethers.utils.solidityPack([
        'bytes32',
        'uint32',
        'bytes32',
        'bytes32[32]',
        'uint8',
        'bytes',
        'address[]',
    ], [
        metadata.checkpointRoot,
        metadata.checkpointIndex,
        addressToBytes32(metadata.originMailbox),
        metadata.proof,
        metadata.signatures.length,
        ethers_1.ethers.utils.hexConcat(metadata.signatures),
        metadata.validators,
    ]);
};
exports.formatLegacyMultisigIsmMetadata = formatLegacyMultisigIsmMetadata;
/**
 * JS Implementation of solidity/contracts/libs/Message.sol#formatMessage
 * @returns Hex string of the packed message
 */
const formatMessage = (version, nonce, originDomain, senderAddr, destinationDomain, recipientAddr, body) => {
    senderAddr = addressToBytes32(senderAddr);
    recipientAddr = addressToBytes32(recipientAddr);
    return ethers_1.ethers.utils.solidityPack(['uint8', 'uint32', 'uint32', 'bytes32', 'uint32', 'bytes32', 'bytes'], [
        version,
        nonce,
        originDomain,
        senderAddr,
        destinationDomain,
        recipientAddr,
        body,
    ]);
};
exports.formatMessage = formatMessage;
/**
 * Get ID given message bytes
 * @param message Hex string of the packed message (see formatMessage)
 * @returns Hex string of message id
 */
function messageId(message) {
    return ethers_1.ethers.utils.solidityKeccak256(['bytes'], [message]);
}
exports.messageId = messageId;
/**
 * Parse a serialized Hyperlane message from raw bytes.
 *
 * @param message
 * @returns
 */
function parseMessage(message) {
    const VERSION_OFFSET = 0;
    const NONCE_OFFSET = 1;
    const ORIGIN_OFFSET = 5;
    const SENDER_OFFSET = 9;
    const DESTINATION_OFFSET = 41;
    const RECIPIENT_OFFSET = 45;
    const BODY_OFFSET = 77;
    const buf = Buffer.from(ethers_1.utils.arrayify(message));
    const version = buf.readUint8(VERSION_OFFSET);
    const nonce = buf.readUInt32BE(NONCE_OFFSET);
    const origin = buf.readUInt32BE(ORIGIN_OFFSET);
    const sender = ethers_1.utils.hexlify(buf.slice(SENDER_OFFSET, DESTINATION_OFFSET));
    const destination = buf.readUInt32BE(DESTINATION_OFFSET);
    const recipient = ethers_1.utils.hexlify(buf.slice(RECIPIENT_OFFSET, BODY_OFFSET));
    const body = ethers_1.utils.hexlify(buf.slice(BODY_OFFSET));
    return { version, nonce, origin, sender, destination, recipient, body };
}
exports.parseMessage = parseMessage;
function domainHash(domain, mailbox) {
    return ethers_1.ethers.utils.solidityKeccak256(['uint32', 'bytes32', 'string'], [domain, addressToBytes32(mailbox), 'HYPERLANE']);
}
exports.domainHash = domainHash;
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
exports.sleep = sleep;
// Retries an async function if it raises an exception,
// with exponential backoff.
// If all the tries fail it raises the last thrown exception
async function retryAsync(runner, attempts = 5, baseRetryMs = 50) {
    let saveError;
    for (let i = 0; i < attempts; i++) {
        try {
            const result = await runner();
            return result;
        }
        catch (error) {
            saveError = error;
            await sleep(baseRetryMs * 2 ** i);
        }
    }
    throw saveError;
}
exports.retryAsync = retryAsync;
async function pollAsync(runner, delayMs = 500, maxAttempts = undefined) {
    let attempts = 0;
    let saveError;
    while (!maxAttempts || attempts < maxAttempts) {
        try {
            const ret = await runner();
            return ret;
        }
        catch (error) {
            saveError = error;
            attempts += 1;
            await sleep(delayMs);
        }
    }
    throw saveError;
}
exports.pollAsync = pollAsync;
function median(a) {
    const sorted = a.slice().sort();
    const mid = Math.floor(sorted.length / 2);
    const median = sorted.length % 2 == 0 ? (sorted[mid] + sorted[mid + 1]) / 2 : sorted[mid];
    return median;
}
exports.median = median;
function sum(a) {
    return a.reduce((acc, i) => acc + i);
}
exports.sum = sum;
function mean(a) {
    return sum(a) / a.length;
}
exports.mean = mean;
function stdDev(a) {
    const xbar = mean(a);
    const squaredDifferences = a.map((x) => Math.pow(x - xbar, 2));
    return Math.sqrt(mean(squaredDifferences));
}
exports.stdDev = stdDev;
function streamToString(stream) {
    return new Promise((resolve, reject) => {
        const chunks = [];
        stream
            .setEncoding('utf8')
            .on('data', (chunk) => chunks.push(chunk))
            .on('error', (err) => reject(err))
            .on('end', () => resolve(String.prototype.concat(...chunks)));
    });
}
exports.streamToString = streamToString;
function isValidSignature(signature) {
    return typeof signature === 'string'
        ? ethers_1.ethers.utils.isHexString(signature)
        : ethers_1.ethers.utils.isHexString(signature.r) &&
            ethers_1.ethers.utils.isHexString(signature.s) &&
            Number.isSafeInteger(signature.v);
}
function isS3Checkpoint(obj) {
    return isValidSignature(obj.signature) && isCheckpoint(obj.value);
}
exports.isS3Checkpoint = isS3Checkpoint;
function isS3CheckpointWithId(obj) {
    return (isValidSignature(obj.signature) &&
        isCheckpoint(obj.value.checkpoint) &&
        ethers_1.ethers.utils.isHexString(obj.value.message_id));
}
exports.isS3CheckpointWithId = isS3CheckpointWithId;
function isCheckpoint(obj) {
    const isValidRoot = ethers_1.ethers.utils.isHexString(obj.root);
    const isValidIndex = Number.isSafeInteger(obj.index);
    const isValidMailbox = ethers_1.ethers.utils.isHexString(obj.mailbox_address);
    const isValidDomain = Number.isSafeInteger(obj.mailbox_domain);
    return isValidIndex && isValidRoot && isValidMailbox && isValidDomain;
}
exports.isCheckpoint = isCheckpoint;
/**
 * Wait up to a given amount of time, and throw an error if the promise does not resolve in time.
 * @param promise The promise to timeout on.
 * @param timeoutMs How long to wait for the promise in milliseconds.
 * @param message The error message if a timeout occurs.
 */
function timeout(promise, timeoutMs, message = 'Timeout reached') {
    if (!timeoutMs || timeoutMs <= 0)
        return promise;
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(new Error(message));
        }, timeoutMs);
        promise.then(resolve).catch(reject);
    });
}
exports.timeout = timeout;
// Should be used instead of referencing process directly in case we don't
// run in node.js
function safelyAccessEnvVar(name) {
    try {
        return process.env[name];
    }
    catch (error) {
        return undefined;
    }
}
exports.safelyAccessEnvVar = safelyAccessEnvVar;
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#implementing_basic_set_operations
function difference(a, b) {
    const _difference = new Set(a);
    for (const elem of b) {
        _difference.delete(elem);
    }
    return _difference;
}
exports.difference = difference;
function symmetricDifference(a, b) {
    const _difference = new Set(a);
    for (const elem of b) {
        if (_difference.has(elem)) {
            _difference.delete(elem);
        }
        else {
            _difference.add(elem);
        }
    }
    return _difference;
}
exports.symmetricDifference = symmetricDifference;
function setEquality(a, b) {
    return symmetricDifference(a, b).size === 0;
}
exports.setEquality = setEquality;
async function runWithTimeout(timeoutMs, callback) {
    let timeout;
    const timeoutProm = new Promise((_, reject) => (timeout = setTimeout(() => reject(new Error(`Timed out in ${timeoutMs}ms.`)), timeoutMs)));
    const ret = await Promise.race([callback(), timeoutProm]);
    // @ts-ignore timeout gets set immediately by the promise constructor
    clearTimeout(timeout);
    return ret;
}
exports.runWithTimeout = runWithTimeout;
//# sourceMappingURL=utils.js.map